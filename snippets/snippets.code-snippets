{
    "Descending order Assembly Language":{
        "prefix": "!descendingOrder",
        "body": [
            "MOV SI,1100H",
            "MOV CL,[SI]",
            "DEC CL",
            "REPEAT:",
            "MOV SI,1100H",
            "MOV CH,[SI]",
            "DEC CH",
            "INC SI",
            "RECOMP:",
            "MOV AL,[SI]",
            "INC SI",
            "CMP AL,[SI]",
            "JNC AHEAD"  ,              
            "XCHG AL,[SI]",
            "XCHG AL,[SI-1]",
            "AHEAD:",
            "DEC CH",
            "JNZ RECOMP",
            "DEC CL",
            "JNZ REPEAT",
            "HLT"  
        ],
        "description": "Descending order Assembly Language"
    },
    "Ascending order Assembly Language":{
        "prefix": "!ascendingOrder",
        "body": [
            "MOV SI,1100H",
            "MOV CL,[SI]",
            "DEC CL",
            "REPEAT:",
            "MOV SI,1100H",
            "MOV CH,[SI]",
            "DEC CH",
            "INC SI",
            "RECOMP:",
            "MOV AL,[SI]",
            "INC SI",
            "CMP AL,[SI]",
            "JC AHEAD",
            "XCHG AL,[SI]",
            "XCHG AL,[SI-1]",
            "AHEAD:",
            "DEC CH",
            "JNZ RECOMP",
            "DEC CL",
            "JNZ REPEAT",
            "HLT"
        ],
        "description": "Ascending order Assembly Language"
    },
    "Shortest Number Assembly Language":{
        "prefix": "!shortestNumber",
        "body": [
            "MOV SI,1100H",
            "MOV DI,1200H",
            "MOV CL,[SI]",
            "INC SI",
            "MOV AL,[SI]",
            "DEC CL",
            "AGAIN:",
            "INC SI",
            "MOV BL,[SI]",
            "CMP AL,BL",
            "JC AHEAD",         
            "MOV AL,BL",
            "AHEAD:",
            "DEC CL",
            "JNZ AGAIN",
            "MOV [DI],AL",
            "HLT"   
        ],
        "description": "Shortest Number Assembly Language"
    },
    "Largest Number Assembly Language":{
        "prefix": "!largestNumber",
        "body": [
            "MOV SI,1100H",
            "MOV DI,1200H",
            "MOV CL,[SI]",
            "INC SI",
            "MOV AL,[SI]",
            "DEC CL",
            "AGAIN:",
            "INC SI",
            "MOV BL,[SI]",
            "CMP AL,BL",
            "JNC AHEAD",
            "MOV AL,BL",
            "AHEAD:",
            "DEC CL",
            "JNZ AGAIN",
            "MOV [DI],AL",
            "HLT"
        ],
        "description": "Largest Number Assembly Language"
    },
    "Factorial without macros":{
        "prefix": "!factorialwithoutmacros",
        "body": [
            "DATA SEGMENT",
            "A DB 5",
            "fact DB ?",
            "DATA ENDS",
            "CODE SEGMENT",
            "         ASSUME DS:DATA,CS:CODE",
            "START:",
            "      MOV AX,DATA",
            "      MOV DS,AX",
            "      MOV AH,00",
            "      MOV AL,A",
            " L1:  DEC A",
            "      MUL A",
            "      MOV CL,A",
            "      CMP CL,01",
            "      JNZ L1",
            "      MOV fact, AL",
            "CODE ENDS",
            "END START"
            
        ],
        "description": "Factorial without macros"
    },
    "Factorial using macros":{
        "prefix": "!factorialwithmacros",
        "body": [
            "fact macro f",
            "    up:",
            "    mul f",
            "    dec f",
            "    jnz up",
            "endm",
            "data segment",
            "    num dw 05h",
            "    result dw ?",
            "ends",
            "stack segment",
            "    dw 128 dup(0)",
            "ends",
            "code segment",
            "    start:",
            "    mov ax,data",
            "    mov ds,ax",
            "    mov cx,num",
            "    mov ax, 0001h",
            "    fact num",
            "    mov result,ax",
            "ends"
        ],
        "description": "Factorial using macros"
    },
    "Python Gui":{
        "prefix": "!pythongui",
        "body": [
            "import tkinter as tk",
            "from tkinter import *",
            "root = tk.Tk()",
            "root.geometry('350x200')",
            "root.title('Login Form')",
            "label1 = tk.Label(root, text='Username: ')",
            "label1.grid()",
            "label2 = tk.Label(root, text='Password: ')",
            "print(type(label1))",
            "label2.grid()",
            "Username = tk.Entry(root, width=20)",
            "Password = tk.Entry(root, width=20)",
            "Username.grid(row=0, column=1)",
            "Password.grid(row=1, column=1)",
            "def SubmitForm(Username, Password):",
            "    user_list = []",
            "    pass_list = []",
            "    if Username not in user_list and Password not in pass_list:",
            "        user_list.append(Username)",
            "        pass_list.append(Password)",
            "        next_window = Toplevel(root)",
            "        next_window.geometry('350x200')",
            "        next_window.title('Showing User Details')",
            "        label5 = tk.Label(next_window, text='Username:')",
            "        label5.grid(row=0, column=0)",
            "        label6 = tk.Label(next_window, text='Password:')",
            "        label6.grid(row=1, column=0)",
            "        label3 = tk.Label(next_window, text=Username)",
            "        label3.grid(row=0, column=1)",
            "        label4 = tk.Label(next_window, text=Password)",
            "        label4.grid(row=1, column=1)",
            "def print_details():",
            "    Uss = Username.get()",
            "    passw = Password.get()",
            "    SubmitForm(Uss, passw)",
            "Button = tk.Button(root, text='Click for Submit', command=print_details)",
            "Button.grid(row=2, column=1)",
            "root.mainloop()"      
            
        ],
        "description": "Python Gui"
    },
    "Addition in assembly language":{
        "prefix": "!additionAssembly",
        "body": [
            "MOV AX,[1000H]",
            "MOV BX,[1002H]",
            "MOV CL,00H",
            "ADD AX,BX",
            "MOV [1004H],AX",
            "JNC JUMP",
            "INC CL",
            "JUMP:",
            "MOV [1006H],CL",
            "HLT"
        ],
        "description": "Addition in assembly language"        
    },
    "Subtraction in assembly language":{
        "prefix": "!subtractionAssembly",
        "body": [
            "MOV AX,[1000H]",
            "MOV BX,[1002H]",
            "MOV CL,00H",
            "SUB AX,BX",
            "JNC JUMP",
            "INC CL",
            "NOT AX",
            "ADD AX,0001H",
            "JUMP:",
            "MOV [1004H],AX",
            "MOV [1006H],CL",
            "HLT"         
        ],
        "description": "Subtraction in assembly language"        
    },
    "Multiplication in assembly language":{
        "prefix": "!multiplicationAssembly",
        "body": [
            "MOV SI,1100H",
            "MOV AX,[SI]",
            "MOV BX,[SI+2]",
            "MUL BX",
            "MOV [SI+4],AX",
            "MOV [SI+6],DX",
            "HLT"              
        ],
        "description": "Multiplication in assembly language"        
    },
    "Division in assembly language":{
        "prefix": "!divisionAssembly",
        "body": [
            "MOV SI,1100H",
            "MOV AX,[SI]",
            "MOV BX,[SI+2]",
            "DIV BX",
            "MOV [SI+6],AX",
            "MOV [SI+8],DX",
            "HLT"              
        ],
        "description": "Division in assembly language"        
    },
    "Simple Interest In Assembly Language":{
        "prefix": "!simpleInterestAssembly",
        "body": [
            "#include<stdio.h>",
            "#include<conio.h>",
            "#include<string.h>",
            "void main()",
            "{",
            "    int p, r, t, result, i,j;",
            "    clrscr();",
            "    printf(\"Enter Principal amount:\");",
            "    scanf(\"%d\",&p);",
            "    printf(\"Enter Rate of Interest:\");",
            "    scanf(\"%d\",&r);",
            "    printf(\"Enter Total time(in months):\");",
            "    scanf(\"%d\",&t);",
            "    asm mov ax,p;",
            "    asm mov bx,r;",
            "    asm mul bx;" ,
            "    asm mul t;",
            "    asm mov result,ax;",
            "    printf(\"Simple Interest:%d\\n\",result/100);",
            "    getch();",
            "}"
        ],
        "description": "Simple Interest In Assembly Language"        
    },
    "ExchangeDataSegment":{
        "prefix": "!exchangeDataSegment",
        "body": [
            "data segment",
            "src db 0x90, 0x34, 0x45, 0x21",
            "data ends",
            "extra segment ",
            "dest db ?",
            "extra ends",
            "code segment",
            "assume cs:code, ds:data, es:extra",
            "start:",
            "mov ax, data",
            "mov ds, ax",
            "mov ax, extra",
            "mov es, ax",
            "lea si, src",
            "lea di, dest",
            "mov cx, 0x04",
            "cld",
            "rep",
            "movsb",
            "end start",
            "code ends",
        ],
        "description": "ExchangeDataSegment"        
    },
    "Worst Fit Algorithm": {
        "prefix": "!worstfitpython",
        "body": [
            "def worstFit(blockSize, m, processSize, n):",
            "    allocation = [-1] * n",
            "    for i in range(n):",
            "        wstIdx = -1",
            "        for j in range(m):",
            "            if blockSize[j] >= processSize[i]:",
            "                if wstIdx == -1:",
            "                    wstIdx = j",
            "                elif blockSize[wstIdx] < blockSize[j]:",
            "                    wstIdx = j",
            "        if wstIdx != -1:",
            "            allocation[i] = wstIdx",
            "            blockSize[wstIdx] -= processSize[i]",
            "    print(\"Process No. Process Size Block no.\")",
            "    for i in range(n):",
            "        print(i + 1, \"         \", processSize[i], end = \"     \")",
            "        if allocation[i] != -1:",
            "            print(allocation[i] + 1)",
            "        else:",
            "            print(\"Not Allocated\")",
            "if __name__ == '__main__':",
            "    blockSize = [100, 500, 200, 300, 600]",
            "    processSize = [212, 417, 112, 426]",
            "    m = len(blockSize)",
            "    n = len(processSize)",
            "    worstFit(blockSize, m, processSize, n)",
        ],
        "description": "Worst Fit Algorithm" 
    },
    "First Fit Algorithm": {
        "prefix": "!firstfitpython",
        "body": [
            "def firstFit(blockSize, m, processSize, n):",
            "    allocation = [-1] * n",
            "    for i in range(n):",
            "        for j in range(m):",
            "            if blockSize[j] >= processSize[i]:",
            "                allocation[i] = j",
            "                blockSize[j] -= processSize[i]",
            "                break",
            "    print(\"Process No. Process Size      Block no.\")",
            "    for i in range(n):",
            "        print(\" \", i + 1, \"         \", processSize[i],\"         \", end = \" \")",
            "        if allocation[i] != -1:",
            "            print(allocation[i] + 1)",
            "        else:",
            "            print(\"Not Allocated\")",
            "if __name__ == '__main__':",
            "    blockSize = [100, 500, 200, 300, 600]",
            "    processSize = [212, 417, 112, 426]",
            "    m = len(blockSize)",
            "    n = len(processSize)",
            "    firstFit(blockSize, m, processSize, n)",
        ],
        "description": "First Fit Algorithm" 
    },
    "Best Fit Algorithm": {
        "prefix": "!bestfitpython",
        "body": [
            "def bestFit(blockSize, m, processSize, n):",
            "    allocation = [-1] * n",
            "    for i in range(n):",
            "        bestIdx = -1",
            "        for j in range(m):",
            "            if blockSize[j] >= processSize[i]:",
            "                if bestIdx == -1:",
            "                    bestIdx = j",
            "                elif blockSize[bestIdx] > blockSize[j]:",
            "                    bestIdx = j",
            "        if bestIdx != -1:",
            "            allocation[i] = bestIdx",
            "            blockSize[bestIdx] -= processSize[i]",
            "    print(\"Process No. Process Size      Block no.\")",
            "    for i in range(n):",
            "        print(i + 1, \"         \", processSize[i], end = \"     \")",
            "        if allocation[i] != -1:",
            "            print(allocation[i] + 1)",
            "        else:",
            "            print(\"Not Allocated\")",
            "if __name__ == '__main__':",
            "    blockSize = [100, 500, 200, 300, 600]",
            "    processSize = [212, 417, 112, 426]",
            "    m = len(blockSize)",
            "    n = len(processSize)",
            "    bestFit(blockSize, m, processSize, n)",
        ],
        "description": "Best Fit Algorithm" 
    },
    "Next Fit Algorithm": {
        "prefix": "!nextfitpython",
        "body": [
            "def NextFit(blockSize, m, processSize, n):",
            "    allocation = [-1] * n",
            "    j = 0",
            "    t = m-1",
            "    for i in range(n):",
            "        while j < m:",
            "            if blockSize[j] >= processSize[i]:",
            "                allocation[i] = j",
            "                blockSize[j] -= processSize[i]",
            "                t = (j - 1) % m",
            "                break",
            "            if t == j:",
            "                t = (j - 1) % m",
            "                break",
            "            j = (j + 1) % m",
            "    print(\"Process No. Process Size Block no.\")" ,
            "    for i in range(n):",
            "        print(i + 1, \"\\t\\t\", processSize[i],end = \"\\t \")",
            "        if allocation[i] != -1:",
            "            print(allocation[i] + 1)",
            "        else:",
            "            print(\"Not Allocated\")",
            "if __name__ == '__main__':",
            "    blockSize = [5, 10, 20]",
            "    processSize = [10, 20, 5]",
            "    m = len(blockSize)",
            "    n = len(processSize)",
            "    NextFit(blockSize, m, processSize, n)"
        ],
        "description": "Next Fit Algorithm" 
    },
    "Python Regex" : {
        "prefix": "!regexpython",
        "body": [
            "import re",
            "tp = open('myfile.txt', 'r')",
            "mail = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'",
            "number = r'\\S[^a-zA-Z\\n]+\\d+\\S[^a-zA-Z\\n]'",
            "sitee = r\"(http|https)://[\\w\\-]+(\\.[\\w\\-]+)+\\S*\"",
            "name = r'Mr.+|Mrs.+'",
            "m = tp.read()",
            "m = m.split('\\n')",
            "mails = []",
            "numbers = []",
            "names = []",
            "for i in m:",
            "    if (re.match(mail, i)):",
            "        mails.append(i)",
            "    elif re.match(number, i):",
            "        numbers.append(i)",
            "    elif re.match(name, i):",
            "        names.append(i)",
            "print(\"Mails :\",mails,\"\\nNumbers:\", numbers,\"\\nNames:\", names,\"\\n\")",
        ],
        "description": "Python Regex"         
    },
    "Python Inheritance":{
        "prefix": "!inheritancepython",
        "body": [
            "class Employee:",
            "    def __init__(self,id,name,Type):",
            "        self.id = id",
            "        self.name = name",
            "        self.Type = Type",
            "class Manager(Employee):",
            "    def __init__(self, id, name):",
            "        super().__init__(id, name, Type=\"Manger\")",
            "        self.MangerID = 100*id+id",
            "        self.testers=[]",
            "        self.developers=[]",
            "    def add_tester(self,id):",
            "        self.testers.append(id)",
            "    def remove_tester(self,id):",
            "        self.testers.remove(id)",
            "    def add_developer(self,id):",
            "        self.developers.append(id)",
            "    def remove_developer(self,id):",
            "        self.developers.remove(id)",
            "class Tester(Employee):",
            "    def __init__(self, id, name):",
            "        super().__init__(id, name, Type=\"Tester\")",
            "        self.TesterID = 100*id+id",
            "class Developer(Employee):",
            "    def __init__(self, id, name):",
            "        super().__init__(id, name, Type=\"Developer\")",
            "        self.DeveloperID = 100*id+id",
            "m1 = Manager(1,\"Rohan\")",
            "m2 = Manager(1,\"Raj\")",
            "t1 = Tester(2,\"Tester1\")",
            "t2 = Tester(3,\"Tester2\")",
            "d1 = Developer(4,\"dev\")",
            "m1.add_developer(d1.id)",
            "m1.add_tester(t1.id)",
            "m2.add_tester(t2.id)",
            "print(f\"For Manger 1:\\nTester:{m1.testers}\\nDevelopers:{m1.developers}\")",
            "print(f\"For Manger 2:\\nTester:{m2.testers}\\nDevelopers:{m2.developers}\")"

        ],
        "description": "Python Inheritance" 
    },
    "Client Server Python" : {
        "prefix": "!clientserverpython",
        "body": [
            "#Client",
            "import socket",
            "def mpm():",
            "    host = '127.0.0.1'",
            "    port = 6000",
            "    s = socket.socket()",
            "    s.connect((host, port))" , 
            "    while True:",
            "        x = input(\"Enter New Message : \")",
            "        y = x.encode('ascii')",
            "        s.send(y)",
            "        data = s.recv(1024)",
            "        d = data.decode('ascii')",
            "        print(\"Server: \",d)", 
            "mpm()",
            "#Sever",
            "import socket",
            "def mpm():",
            "    host = '127.0.0.1'",
            "    port = 6000",
            "    s = socket.socket()",
            "    s.bind((host, port))",
            "    s.listen(1)",
            "    c, addr = s.accept()" ,  
            "    print(\"Client Address : \", addr)" , 
            "    while True:",
            "        data = c.recv(1024)",
            "        d = data.decode('ascii')",
            "        print(\"Client: \", d)",
            "        x = input(\">>> \")",
            "        y = x.encode('ascii')",
            "        c.send(y)",
            "mpm()"
        ],
        "description": "Client Server Python" 
    },
    "Restoring Division" : {
        "prefix": "!restoringdivision",
        "body": [
            "def decimalToBinary(n):",
            "    return bin(n).replace(\"0b\", \"\")",
            "def add(A, M):",
            "    carry = 0",
            "    add_sum = ''",            
            "    for i in range(len(A) - 1, -1, -1):",
            "        temp = int(A[i]) + int(M[i]) + carry",
            "        if (temp > 1):",
            "            add_sum += str(temp % 2)",
            "            carry = 1",
            "        else:",
            "            add_sum += str(temp)",
            "            carry = 0",
            "    return add_sum[::-1]",     
            "def compliment(m):",
            "    M = ''",
            "    for i in range(0, len(m)):",
            "        M += str((int(m[i]) + 1) % 2)"      , 
            "    M = add(M, '0' * (len(M) - 1) + '1')",
            "    return M"         ,
            "def restoringDivision(Q, M, A):",
            "    count = len(M)",
            "    print(f'Initial Values: A: {A}, Q: {Q}, M: {M}')",
            "    while(count):",
            "        print(f'Step: {len(M) - count + 1}', end = ' ')",
            "        print('Left Shift and Subtract: ', end = ' ')",
            "        A = A[1:] + Q[0]",
            "        comp_M = compliment(M)",
            "        A = add(A, comp_M)",
            "        print(f'A: {A}')",
            "        print(f'A: {A}, Q: {Q[1:]}_', end='')",
            "        if (A[0] == '1'):",
            "            Q = Q[1:] + '0'",
            "            print('  -Unsuccessful')",
            "            A = add(A, M)",
            "            print(f'A: {A}, Q: {Q}  -Restoration')",          
            "        else:",
            "            Q = Q[1:] + '1'",
            "            print('  -Successful')",
            "            print(f'A: {A}, Q: {Q}  -No Restoration')",
            "        count -= 1",         
            "    print()",
            "    print(f'Quotient(Q): {Q}, Remainder(A): {A}')",          
            "if __name__ == \"__main__\":",
            "    tdividend = int(input('Enter dividend: '))",
            "    dividend=decimalToBinary(tdividend)",
            "    tdivisor = int(input('Enter divisor: '))",
            "    divisor='0'+decimalToBinary(tdivisor)",
            "    print(divisor)",
            "    accumulator = '0' * len(dividend)",
            "    restoringDivision(dividend, divisor, accumulator)"
        ],
        "description": "Restoring Division" 
    },
    "NonRestoring Division" : {
        "prefix": "!nonrestoringdivision",
        "body": [
            "def decimalToBinary(n):",
            "    return bin(n).replace(\"0b\", \"\")",           
            "def add(A, M):",
            "    carry = 0",
            "    add_sum = ''",
            "    for i in range(len(A) - 1, -1, -1):",
            "        temp = int(A[i]) + int(M[i]) + carry",
            "        if (temp > 1):",
            "            add_sum += str(temp % 2)",
            "            carry = 1",
            "        else:",
            "            add_sum += str(temp)",
            "            carry = 0",
            "    return add_sum[::-1]",         
            "def compliment(m):",
            "    M = ''",
            "    for i in range(0, len(m)):",
            "        M += str((int(m[i]) + 1) % 2)"   ,
            "    M = add(M, '0' * (len(M) - 1) + '1')",
            "    return M",
            "def nonRestoringDivision(Q, M, A):",
            "    count = len(M)",
            "    comp_M = compliment(M)",
            "    flag = 'successful'",
            "    print('Initial Values: A:', A, ' Q:', Q, ' M:', M)",
            "    while (count):",
            "        print(f'Step: {len(M)-count + 1}', end = ' ')",
            "        print('Left Shift and', end = ' ')",
            "        A = A[1:] + Q[0]",
            "        if (flag == 'successful'):",
            "            A = add(A, comp_M)",
            "            print('Subtraction: ')",
            "        else:",
            "            A = add(A, M)",
            "            print('Addition: ')",
            "        print(f'A: {A}, Q: {Q[1:]}_', end='')",
            "        if (A[0] == '1'):",
            "            Q = Q[1:] + '0'",
            "            print('  -Unsuccessful')",
            "            flag = 'unsuccessful'",
            "            print(f'A: {A}, Q: {Q} -Addition in next Step')",
            "        else:",
            "            Q = Q[1:] + '1'",
            "            print('  Successful')",
            "            flag = 'successful'",
            "            print(f'A: {A}, Q: {Q}, -Subtraction in next step')",
            "        count -= 1",
            "    if (A[0] == '1'):",
            "        A = add(A, M) ",
            "    print()",
            "    print(f'Quotient(Q): {Q}, Remainder(A): {A}')"  ,
            "if __name__ == \"__main__\":",
            "    tdividend = int(input('Enter dividend: '))",
            "    dividend=decimalToBinary(tdividend)",
            "    tdivisor = int(input('Enter divisor: '))",
            "    divisor='0'+decimalToBinary(tdivisor)",
            "    accumulator = '0' * len(dividend)",
            "    nonRestoringDivision(dividend, divisor, accumulator)"
        ],
        "description": "NonRestoring Division" 
    },
    "Booths Algorithm" : {
        "prefix": "!boothsalgorithm",
        "body": [
            "def booths_algorithm():",
            "    multiplicand_dec = getInput(\"Mutiplicand\")",
            "    multiplier_dec = getInput(\"Multiplier\")",
            "    multiplicand_bin = convertDec(multiplicand_dec)",
            "    multiplier_bin = convertDec(multiplier_dec)",
            "    boothsTriumph(multiplicand_bin,multiplier_bin)",
            "    print(\"Decimal Result: \" + str(int(multiplier_dec)*int(multiplicand_dec)))",
            "def boothsTriumph(mcand, plier):",
            "    print(\"Multipcand: \" + mcand + \" Multiplier: \" + plier)",
            "    product = \"00000000\" + plier + \"0\"",
            "    print(\"Product: \" + product)",
            "    print(buildLine(0,mcand,product))",
            "    for i in range(1,9):",
            "        operation = product[len(product)-2:]",
            "        product = perform_operation(product,mcand,operation)",
            "        print(buildLine(i,mcand,product))",
            "    product = shift(product)",
            "    product = product[9:17]",
            "    print(\"Product: \" + product)",
            "    return",
            "def perform_operation(product,mcand,operation):",
            "    if operation == \"00\":",
            "        product = shift(product)",
            "        print(\"No Op\")",
            "        return product",
            "    elif operation == \"01\":",
            "        temp = binAdd(product[0:8],mcand)",
            "        product = temp + product[8:]",
            "        product = shift(product)",
            "        print(\"Add\")",
            "        return product",
            "    elif operation == \"10\":",
            "        product = subtraction(product,mcand)",
            "        product = shift(product)",
            "        print(\"Sub\")",
            "        return product",
            "    elif operation == \"11\":",
            "        product = shift(product)",
            "        print(\"No Op\")",
            "        return product",
            "    else:",
            "        print(\"An error has occured when choosing operation: Exiting program\")",
            "        return 0",
            "def subtraction(product,mcand):",
            "    carry = 0",
            "    prime_product = product[:8]",
            "    final_product = \"\"", 
            "    for i in range(len(prime_product)-1,-1,-1):",
            "        if (mcand[i] == \"0\" and prime_product[i] == \"0\"):",
            "            if (carry == 1):",
            "                final_product = \"1\" + final_product",
            "            else:",
            "                final_product = \"0\" + final_product",
            "        elif (mcand[i] == \"1\" and prime_product[i] == \"0\"):",
            "            if (carry == 1):",
            "                final_product = \"0\" + final_product",
            "            else:",
            "                final_product = \"1\" + final_product",
            "                carry = 1",
            "        elif (mcand[i] == \"0\" and prime_product[i] == \"1\"):",
            "            if (carry == 1):",
            "                final_product = \"0\" + final_product",
            "                carry = 0",
            "            else:",
            "                final_product = \"1\" + final_product",
            "        elif (mcand[i] == \"1\" and prime_product[i] == \"1\"):",
            "            if (carry == 1):",
            "                final_product = \"1\" + final_product",
            "                carry = 1",
            "            else:",
            "                final_product = \"0\" + final_product",
            "        else:",
            "            print(\"An error has occurred when subtracting: Exiting program\")",
            "            return 0",
            "    return final_product + product[8:]",
            "def shift(product):",
            "    product = \"0\"+product[:len(product)-1]",
            "    return product",
            "def binAdd(num, num2):",
            "    product = \"\"",
            "    carry = \"0\"",
            "    for i in range(len(num)-1,-1,-1):",
            "        if carry == \"0\":",
            "            if num[i] == \"0\" and num2[i] == \"0\":",
            "                product = \"0\" + product",
            "            elif num[i] == \"1\" and num2[i] == \"1\": #case 1 and 1",
            "                product = \"0\" + product",
            "                carry = \"1\"",
            "            else:",
            "                product = \"1\" + product",
            "        elif carry == \"1\":",
            "            if num[i] == \"0\" and num2[i] == \"0\":",
            "                product = \"1\" + product",
            "                carry = \"0\"",
            "            elif num[i] == \"1\" and num2[i] == \"1\": #case 1 and 1",
            "                product = \"1\" + product",
            "                carry = \"1\"",
            "            else:",
            "                product = \"0\" + product",
            "                carry = \"1\"",
            "    return product",
            "def buildLine(iteration, mcand, product):",
            "    line = \"Step: \" + str(iteration) + \" | Multiplicand: \" + mcand + \" | Product: \" \\",
            "    + product[0:8] + \" | \" + product[8:16] + \" | \" + product[16]",
            "    return line",
            "def convertDec(dec):",
            "    if int(dec)<0:",
            "        bin = twos_complement(int(dec))",
            "    else:",
            "        bin = \"{0:b}\".format(int(dec))",
            "        for i in range(8-len(bin)):",
            "            bin = \"0\" + bin",
            "    return bin",
            "def getInput(varName):",
            "    boothIn = input('Please enter your ' + varName + \": \")",
            "    while int(boothIn)>127 or int(boothIn)<-128:",
            "        print(\"Absolute value too big, please try again\")",
            "        boothIn = input('Please enter your ' + varName + \": \")",
            "    return boothIn",
            "def twos_complement(dec):",
            "    adjusted = abs(int(dec) + 1)",
            "    binint = \"{0:b}\".format(adjusted)",
            "    flipped = flip(binint)",
            "    for i in range(8-len(flipped)):",
            "        flipped = \"1\" + flipped",
            "    return flipped",
            "def flip(string):",
            "    flipped_string = \"\"",
            "    for bit in string:",
            "        if bit == \"1\":",
            "            flipped_string += \"0\"",
            "        else:",
            "            flipped_string += \"1\"",
            "    return flipped_string",
            "booths_algorithm()"

        ],
        "description": "Booths Algorithm" 
    },

    "MraisedtoN" : {
        "prefix": "!mraisedton",
        "body": [
            "#include<stdio.h> ",
            "#include<conio.h>",
            "#include<string.h>",
            "void main() {",
            "    int m, n, result, i,j;",
            "    clrscr();",
            "    printf(\"Enter no:\");" ,
            "    scanf(\"%d\",&m);",
            "    printf(\"Enter power:\");",
            "    scanf(\"%d\",&n);",
            "    asm{",
            "        mov ax,m"  ,
            "        mov cx,n",
            "        dec cx",
            "    };",
            "    label:",
            "    asm{",
            "        mul m",
            "        dec cx",
            "        jnz label",
            "        mov result,ax",
            "    }",
            "    printf(\"value:%d\\n\",result);",
            "    getch();",
            "}"
        ],
        "description": "MraisedtoN" 
    },

    "Python Pyramid" : {
        "prefix": "!pythonpyramid",
        "body": [
            "n = int(input(\"Enter Number of Lines: \"))",
            "for i in range(1,n+1):",
            "    for j in range(n-i):",
            "        print(\" \",end=\"\")",
            "    for j in range(i):",
            "        print(chr(65+j),end=\"\")",
            "        print(\" \",end=\"\")",
            "    print()" 
        ],
        "description": "Python Pyramid" 
    },
    "Python Triangle" : {
        "prefix": "!pythontriangle",
        "body": [
            "n = int(input(\"Enter Start Number: \"))",
            "for i in range(n+1):",
            "    for j in range(i+1):",
            "        print(n+j-i,end=\" \")",
            "    print()",
            "for i in range(n):",
            "    for j in range(n-i):",
            "        print(i+j+1,end=\" \")",
            "    print()"
        ],
        "description": "Python Triangle" 
    },
    "Python Diamond" : {
        "prefix": "!pythondiamond",
        "body": [
            "n = int(input(\"Enter Number of letters: \"))",
            "for i in range(1,n+1):",
            "    for j in range(n-i):",
            "        print(\" \",end=\"\")",
            "    for j in range(i):",
            "        print(chr(ord('A')+n-i+j),end=\" \")",
            "    print()",
            "for i in range(1,n+1):",
            "    for j in range(i):",
            "        print(\" \",end=\"\")",
            "    for j in range(n-i):",
            "        print(chr(ord('A')+i+j),end=\" \")",
            "    print()"
        ],
        "description": "Python Diamond" 
    },
    "Python File Reverse Lines" : {
        "prefix": "!printlineinreverseorder",
        "body": [
            "f1 = open(\"File1.txt\",\"r\")",
            "lines=f1.readlines()",
            "lines=[i.replace(\"\\n\",\"\") for i in lines]",
            "print(lines)",
            "new_lines=[]",
            "for i in lines:",
            "    temp=''",
            "    for j in range(len(i)):",
            "       temp+=i[len(i)-1-j]",
            "    new_lines.append(temp)",
            "print(new_lines)",
            "f1.close()"
        ],
        "description": "Python File Reverse Lines" 
    },
    "RGM language identifier" : {
        "prefix": "!rgmlanguageidentifier",
        "body": [
            "import re",
            "lines = [\"b6cwwyYt\",\"B3he\",\"a3$\",\"s3iki\",\"e9Bhqia#8\"]",
            "pattern = r\"[a-k][0|3|6|9][a-z|A-Z|0-9|#]*\"",
            "x=[]",
            "for i in lines:",
            "    y=re.findall(pattern,i)",
            "    if len(y)>0 and y[0]== i:",
            "        x.append(y[0])",
            "print(x)"
        ],
        "description": "RGM language identifier" 
    },
    "Valid Mobile Number" : {
        "prefix": "!mobilenumberregex",
        "body": [
            "import re",
            "lines=[\"983765356\",\"1234567890\",\"9780934567\",\"826262626666\"]",
            "pattern =r\"[7|8|9][0-9]{9}\"",
            "x=[]",
            "for i in lines:",
            "    y=re.findall(pattern,i)",
            "    if len(y)>0 and y[0]==i:",
            "        x.append(y[0])",
            "print(x)"
        ],
        "description": "Valid Mobile Number" 
    },
    "Hanoi Problem" : {
        "prefix": "!hanoiproblem",
        "body": [
            "def hanoi(disks,sorc,aux,dest):",
            "    if disks==1:",
            "        print(f\"Move Disk {disks} from {sorc} to {dest}.\")",
            "        return",
            "    hanoi(disks-1,sorc,dest,aux)",
            "    print(f\"Move Disk {disks} from {sorc} to {dest}.\")",
            "    hanoi(disks-1,aux,sorc,dest)",
            "disks = int(input(\"Enter Number of Disks: \"))",
            "hanoi(disks,\"A\",\"B\",\"C\")"
        ],
        "description": "Hanoi Problem" 
    },
    "Exception Handling" : {
        "prefix": "!exceptionhandling",
        "body": [
            "def Valueerror():",
            "    try:",
            "        x = int (input (\"Please enter a number: \"))",
            "    except ValueError:",
            "        print (\"Oops! That was no valid number. Try again...\")",
            "def Import():",
            "    try:",
            "        import request",
            "    except Exception as e:",
            "        print (e)",
            "def Ioerror():",
            "    try:",
            "        file=open(\"hello.txt\",'r')",
            "    except IOError:",
            "        print (\"File does not exist\")",
            "def Arithmetic():",
            "    try:",
            "        n=6",
            "        x=6/0",
            "    except ZeroDivisionError:",
            "        print('You have just made an Arithmetic error')",
            "def Keyboard():",
            "    try:",
            "        x = input()",
            "        print ('Try using KeyboardInterrupt')",
            "    except KeyboardInterrupt:",
            "        print ('KeyboardInterrupt exception is caught')",
            "def name():",
            "    try:",
            "        name = input()",
            "        print(nam)",
            "    except NameError:",
            "        print(\"NameError occurred. Some variable isn't defined.\")",
            "class MyError(Exception):",
            "    def __init__(self, value):",
            "        self.value = value",
            "    def __str__(self):",
            "        return(repr(self.value))",
            "def custom():",
            "    try:",
            "        raise(MyError(3*2))",
            "    except MyError as error:",
            "        print('A New Exception occurred: ', error.value)",
            "    finally:",
            "        print(\"The try...except block is finished\")",
            "Ioerror()",
            "Valueerror()",
            "Arithmetic()",
            "Import()",
            "Keyboard()",
            "name()",
            "custom()"

        ],
        "description": "Exception Handling" 
    },
    "Regex for Website Email" : {
        "prefix": "!regexwebsiteemail",
        "body": [
            "import re",
            "f1 = open(\"File1.txt\",\"r\")",
            "lines = f1.readlines()",
            "f1.close()",
            "lines = [i.replace(\"\\n\",\"\") for i in lines]" ,            
            "name_pattern = r\"[M|m][R|R|S|r|r|s][S|s]{,1}\\..*\"",
            "names=[]",
            "for i in lines:",
            "    y=re.findall(name_pattern,i)",
            "    if len(y)>0 and y[0]==i:",
            "        names.append(y[0])",
            "print(names)"             ,
            "email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z.]{2,}\\b'",
            "emails=[]",
            "for i in lines:",
            "    y=re.findall(email_pattern,i)",
            "    if len(y)>0 and y[0]==i:",
            "        emails.append(y[0])",
            "print(emails)"         ,
            "website_pattern = r\"\\b(http://|https://|www.)[a-zA-Z.]*.[a-zA-Z.]{2,}\"",
            "websites=[]",
            "for i in lines:",
            "    y=re.findall(website_pattern,i)",
            "    if len(y)>0:",
            "        websites.append(i)",
            "print(websites)"         ,
            "number_pattern = r\"\\b[0-9-*]+\"",
            "numberss=[]",
            "for i in lines:",
            "    y=re.findall(number_pattern,i)",
            "    if len(y)>0:",
            "        numberss.append(i)",
            "print(numberss)"
        ],
        "description": "Regex for Website Email" 
    },
    "SQlite3 Python" : {
        "prefix": "!sqlite3python",
        "body": [
            "import sqlite3",
            "myDB= sqlite3.connect(\"test2.db\")",
            "cursor = myDB.cursor()",
            "print()",
            "x=1"          ,   
            "while(x):"         ,  
            "    y=int(input(\"Enter 1 to create table\\n2 to insert value\\n3 to delete value\\n4 to display\\n5 to update\\n0 to exit\\n \"))",
            "    x=y",
            "    if(x==1):",
            "        cursor.execute(\"\"\"CREATE TABLE marks (id int(11),name varchar(50) NOT NULL, total_marks int(3), PRIMARY KEY (id) )\"\"\")",
            "    if(x==2):",
            "        cursor.execute(\"\"\" INSERT INTO marks(id,name,total_marks) VALUES (1,\"roy\",82)\"\"\")",
            "        cursor.execute(\"\"\" INSERT INTO marks(id,name,total_marks) VALUES (2,\"loy\",89)\"\"\")",
            "        myDB.commit()",
            "    if(x==3):",
            "        cursor.execute(\"\"\" DELETE from marks WHERE id=2 \"\"\")"        ,
            "        myDB.commit()",
            "    if(x==4):",
            "        cursor.execute(\"\"\" SELECT * FROM marks \"\"\")",
            "        for x in cursor:",
            "            print(x)",
            "    if(x==5):",
            "        cursor.execute(\"\"\" UPDATE marks SET total_marks = 50 WHERE id=1 \"\"\")"    ,
            "        myDB.commit()",
            "    if(x==0):",
            "        break",
            "myDB.commit()"
        ],
        "description": "SQlite3 Python"
    },

    "Pandas Python" :{
        "prefix": "!pandas python",
        "body": [
            "import pandas as pd",
            "import seaborn as sns",
            "import matplotlib.pyplot as plt"   ,          
            "df = pd.read_csv(\"Iris.csv\")"   ,          
            "df.head()"     ,       
            "df.info()"     ,       
            "#df.dropna(axis=0,how='any')" ,          
            "df['PetalLengthCm']=df['PetalLengthCm'].fillna(df['PetalLengthCm'].mean())"    ,      
            "df.info()"       ,
            "df.dropna(axis=0,how='any')"       ,
            "df.info()"        ,
            "df.describe()"        ,
            "sns.boxplot(df['SepalLengthCm']) "     ,
            "df['Species'].unique()",
            "plt.figure(figsize=(10,10))"    ,
            "means=[]",
            "for i in df['Species'].unique():",
            "  means.append(df[df[\"Species\"]==i][\"SepalLengthCm\"].mean())",
            "plt.bar(x=df['Species'].unique(), height=means)",
            "plt.show() ",
            "plt.pie(x=means,labels=df['Species'].unique())",
            "plt.show()" ,
            "plt.scatter(x=df['PetalLengthCm'],y=df['Species'])",
            "plt.show()",
            "plt.hist(x=df['PetalLengthCm'],bins=10)",
            "plt.show()"
        ],
        "description": "Pandas Python"
    },
    "Tkinter Input Output" :{
        "prefix": "!tkinterinputoutput",
        "body": [
            "from tkinter import *",
            "window= Tk()",
            "window.geometry(\"300x300\") " ,
            "def evaluate():",
            "    x1=first_entry.get()",
            "    x2=second_entry.get()",
            "    op = Operator_entry.get()",
            "    eq = x1+op+x2",
            "    result_entry.config(text=f\"{eval(eq)}\") "   ,    
            "first_value = Label(text=\"Enter Number1: \")",
            "first_value.grid(row=0,column=0)",
            "first_entry = Entry(width=30)",
            "first_entry.grid(row=0,column=1)"  ,
            "second_value = Label(text=\"Enter Number2: \")",
            "second_value.grid(row=1,column=0)",
            "second_entry = Entry(width=30)",
            "second_entry.grid(row=1,column=1)"    ,
            "Operator_value = Label(text=\"Operator: \")",
            "Operator_value.grid(row=2,column=0)",
            "Operator_entry = Entry(width=30)",
            "Operator_entry.grid(row=2,column=1)"  ,  
            "result_value = Label(text=\"Result: \")",
            "result_value.grid(row=3,column=0)",
            "result_entry = Label(text=\"\")",
            "result_entry.grid(row=3,column=1)"  ,
            "btn = Button(text=\"Enter\",command=evaluate)",
            "btn.grid(row=4,column=0,columnspan=2)" ,
            "window.mainloop()"
        ],
        "description": "Tkinter Input Output"
    },
    "Page Rank Algorithm" :{
        "prefix": "!pagerankalgorithm",
        "body": [
            "import numpy as np",
            "def page_rank_algorithm(graph,damping_factor):",
            "    outgoing = dict()",
            "    incoming_nodes = dict()",
            "    coefficients = dict()",
            "    for i in range(len(graph)):",
            "        outgoing[i]=0",
            "    for i,node in enumerate(graph):",
            "        for edge in node:",
            "            if edge:",
            "                outgoing[i] += 1",
            "    for i in range(len(graph)):",
            "        temp=[]",
            "        for node in graph:",
            "            if node[i]:",
            "                temp.append(node)",
            "        incoming_nodes[i] = temp",
            "    for i,node in enumerate(graph):",
            "        temp = []",
            "        for j,other_node in enumerate(graph):",
            "            if other_node in incoming_nodes[i]:",
            "                temp.append(damping_factor*(1.0/outgoing[j]))",
            "            elif i == j:",
            "                temp.append(-1)",
            "            else:",
            "                temp.append(0)",
            "        coefficients[i] = temp",
            "    coefficients_list = []",
            "    for key,value in coefficients.items():",
            "        coefficients_list.append(value)",
            "    constant_matrix = []",
            "    for i in range(len(graph)):",
            "        constant_matrix.append(damping_factor-1)",
            "    pageranks = np.linalg.solve(np.array(coefficients_list),np.array(constant_matrix))",
            "    print()",
            "    for i,rank in enumerate(pageranks):",
            "        print('Page Rank of {} is {:.4f}'.format(chr(65+i), rank))",
            "def main():",
            "    n = int(input('Enter the number of nodes : '))",
            "    d= float(input('Enter the damping factor : '))",
            "    graph = []",
            "    print('Enter Adjacency Matrix with terms separated by a space : ')",
            "    for i in range(n):",
            "        temp_list = input().split(' ')",
            "        graph.append(list(map(int,temp_list)))",
            "    page_rank_algorithm(graph,d)",
            "main()"            
        ],
        "description": "Page Rank Algorithm"
    },
    "Hits Algorithm" :{
        "prefix": "!hitsalgorithm",
        "body": [
            "from math import sqrt",
            "def hits_algorithm(num_nodes, graph, iterations):",
            "    authority_scores = dict()",
            "    hub_scores = dict()",
            "    for i in range(len(graph)):",
            "        authority_scores[i] = 1",
            "        hub_scores[i] = 1",
            "    incoming_nodes = dict()",
            "    for i in range(len(graph)):",
            "        temp=[]",
            "        for node in graph:",
            "            if node[i]:",
            "                temp.append(node)",
            "        incoming_nodes[i] = temp",
            "    outgoing_nodes = dict()",
            "    for i,node in enumerate(graph):",
            "        temp = []",
            "        for j,edge in enumerate(node):",
            "            if edge:",
            "                temp.append(graph[j])",
            "        outgoing_nodes[i] = temp",
            "    print()",
            "    for k in range(iterations):",
            "        print('Iteration : ',k+1)",
            "        print('Authority Score')",
            "        normalization_value = 0",
            "        for i,node in enumerate(graph):",
            "            authority_scores[i]=0",
            "            for j,other_node in enumerate(graph):",
            "                if other_node in incoming_nodes[i]:",
            "                    authority_scores[i] += hub_scores[j]",
            "            normalization_value += (authority_scores[i]**2)",
            "        normalization_value = sqrt(normalization_value)",
            "        for i in range(num_nodes):",
            "            authority_scores[i] /= normalization_value",
            "            print('{} :{:.2f}'.format(chr(65+i),authority_scores[i]),end=' | ')",
            "        print()",
            "        print('Hub Score')",
            "        normalization_value = 0",
            "        for i,node in enumerate(graph):",
            "            hub_scores[i]=0",
            "            for j,other_node in enumerate(graph):",
            "                if other_node in outgoing_nodes[i]:",
            "                    hub_scores[i] += authority_scores[j]",
            "            normalization_value += (hub_scores[i]**2)",
            "        normalization_value = sqrt(normalization_value)",
            "        for i in range(num_nodes):",
            "            hub_scores[i] /= normalization_value",
            "            print('{} :{:.2f}'.format(chr(65+i),hub_scores[i]),end=' | ')",
            "        print(\"\\n\\n\")",
            "def main():",
            "    n = int(input('Enter the no of nodes : '))",
            "    graph = []",
            "    print('Enter Adjacency Matrix : ')",
            "    for i in range(n):",
            "        temp = input()",
            "        temp_list = temp.split(' ')",
            "        graph.append(list(map(int,temp_list)))",
            "    k = int(input('Enter No of Iterations to be performed : '))",
            "    hits_algorithm(n, graph, k)",
            "main()"
            
        ],
        "description": "Page Rank Algorithm"
    },
    "DFS Algorithm" :{
        "prefix": "!dfsalgorithm",
        "body": [
            "graph = {",
            "'5' : ['3','7'],",
            "'3' : ['2', '4'],",
            "'7' : ['8'],",
            "'2' : [],",
            "'4' : ['8'],",
            "'8' : []",
            "}" ,
            "visited = []",
            "queue = []",
            "closed_list=[]",
            "def dfs(visited, graph, node,goal):",
            "    path={}",
            "    path[node]=node",
            "    root=[]",
            "    visited.append(node)",
            "    queue.append(node)",
            "    print(f\"Open List: {queue}\\nClosed list: {closed_list} \")",
            "    print(queue)",
            "    while queue:"      ,  
            "        m = queue.pop()"    ,
            "        closed_list.append(m)",
            "        print(f\"Open List: {queue}\\nClosed list: {closed_list} \")", 
            "        if m==goal:"      ,
            "            while path[m]!=m:",
            "                root.append(m)",
            "                m=path[m]",
            "            root.append(m)",
            "            root.reverse()",
            "            print(f'Path:{root}')",
            "            return",
            "        for neighbour in graph[m]:",
            "            if neighbour not in visited:"    ,
            "                queue.append(neighbour)",
            "                path[neighbour]=m",
            "    print('Path does not exist')",
            "print(\"Following is the Depth-First Search\")",
            "dfs(visited, graph, '5','4')",
        ],
        "description": "DFS Algorithm"
    },
    "BFS Algorithm" :{
        "prefix": "!bfsalgorithm",
        "body": [
            "graph = {",
            "'5' : ['3','7'],",
            "'3' : ['2', '4'],",
            "'7' : ['8'],",
            "'2' : [],",
            "'4' : ['8'],",
            "'8' : []",
            "}",
            "visited = []",
            "queue = []",
            "closed_list=[]",
            "path=[]",
            "def bfs(visited, graph, node,goal):",
            "    visited.append(node)",
            "    path={}",
            "    path[node]=node",
            "    root=[]",
            "    queue.append(node)",
            "    print(f\"Open List: {queue}\\nClosed list: {closed_list} \")",
            "    while queue:",        
            "        m = queue.pop(0)",
            "        closed_list.append(m)",
            "        print(f\"Open List: {queue}\\nClosed list: {closed_list} \")", 
            "        if m==goal:" ,
            "            while path[m]!=m:",
            "                root.append(m)",
            "                m=path[m]",
            "            root.append(m)",
            "            root.reverse()",
            "            print(f'Path:{root}')",
            "            return",
            "        for neighbour in graph[m]:",
            "            if neighbour not in visited:",
            "                visited.append(neighbour)",
            "                queue.append(neighbour)",
            "                path[neighbour]=m",
            "    print(f'Path :{path}')",
            "print(\"Following is the Breadth-First Search\")",
            "bfs(visited, graph, '5','4')"
        ],
        "description": "BFS Algorithm"
    },
    "Hill Climbing" :{
        "prefix": "!hillclimbing",
        "body": [
            "import copy",
            "visited_states = []",
            "def gn(curr_state,prev_heu,goal_state):",
            "    global visited_states",
            "    state = copy.deepcopy(curr_state)",
            "    for i in range(len(state)):",
            "        temp = copy.deepcopy(state)",
            "        if len(temp[i]) > 0:",
            "            elem = temp[i].pop()",
            "            for j in range(len(temp)):",
            "                temp1 = copy.deepcopy(temp)",
            "                if j != i:",
            "                    temp1[j] = temp1[j] + [elem]",
            "                    if (temp1 not in visited_states):",
            "                        curr_heu=heuristic(temp1,goal_state)",
            "                        if curr_heu>prev_heu:",
            "                            child = copy.deepcopy(temp1)",
            "                            return child",
            "    return 0",
            "def heuristic(curr_state,goal_state):",
            "    goal_=goal_state[3]",
            "    val=0",
            "    for i in range(len(curr_state)):",
            "        check_val=curr_state[i]",
            "        if len(check_val)>0:",
            "            for j in range(len(check_val)):",
            "                if check_val[j]!=goal_[j]:",
            "                    val-=j",
            "                else:",
            "                    val+=j",
            "    return val",
            "def sln(init_state,goal_state):",
            "    global visited_states",
            "    if (init_state == goal_state):",
            "        print (goal_state)",
            "        print(\"solution found!\")",
            "        return",
            "    current_state = copy.deepcopy(init_state)",
            "    while(True):",
            "        visited_states.append(copy.deepcopy(current_state))",
            "        print(current_state)",
            "        prev_heu=heuristic(current_state,goal_state)",
            "        child = gn(current_state,prev_heu,goal_state)",
            "        if child==0:",
            "            print(\"Final state - \",current_state)",
            "            return",
            "        current_state = copy.deepcopy(child)",
            "def main():",
            "    global visited_states",
            "    initial = [[],[],[],['B','C','D','A']]",
            "    goal = [[],[],[],['A','B','C','D']]",
            "    sln(initial,goal)",
            "main()"
        ],
        "description": "Hill Climbing"
    },
    "Perceptron" :{
        "prefix": "!perceptron",
        "body": [
            "import numpy as np",
            "X1 = np.array([1, -2, 0, -1])",
            "X2 = np.array([0, 1.5, -0.5, -1])",
            "X3 = np.array([-1, 1, 0.5, -1])",
            "X = [X1, X2, X3]",
            "W = np.array([1, -1, 0, 0.5])",
            "d=[1,-1,-1]",
            "c=0.1",
            "epochs=1",
            "op=0",
            "for i in range(epochs):",
            "    for j in range(3):",
            "        net=np.dot(W,X[j])",
            "        if net==0:",
            "            op=0",
            "        if net>0:",
            "            op=1",
            "        if net<0:",
            "            op=-1",
            "        error=d[j]-op",
            "        dw=c*error*X[j]",
            "        W+=dw",
            "        print(\"W\", j,  W)",
            "print(f'Final weight after epoch is {W}')"
        ],
        "description": "Perceptron"
    },
    "A Star Algorithm" :{
        "prefix": "!astaralgorithm",
        "body": [
            "class Graph:",
            "    def __init__(self, adjacency_list):",
            "        self.adjacency_list = adjacency_list",
            "    def get_neighbors(self, v):",
            "        return self.adjacency_list[v]",
            "    def h(self, n):",
            "        H = {",
            "            'A': 1,",
            "            'B': 1,",
            "            'C': 1,",
            "            'D': 1",
            "        }",
            "        return H[n]",
            "    def a_star_algorithm(self, start_node, stop_node):",
            "        open_list = set([start_node])",
            "        closed_list = set([])",
            "        g = {}",
            "        g[start_node] = 0",
            "        parents = {}",
            "        parents[start_node] = start_node",
            "        while len(open_list) > 0:",
            "            n = None",
            "            print(f'Open list :{open_list} \\nclosed_list:{closed_list}')",
            "            for v in open_list:",
            "                if n == None or g[v] + self.h(v) < g[n] + self.h(n):",
            "                    n = v",
            "            if n == None:",
            "                print('Path does not exist!')",
            "                return None",
            "            if n == stop_node:",
            "                open_list.remove(n)",
            "                closed_list.add(n)",
            "                print(f'Open list :{open_list} \\nclosed_list:{closed_list}')",
            "                reconst_path = []",
            "                while parents[n] != n:",
            "                    reconst_path.append(n)",
            "                    n = parents[n]",
            "                reconst_path.append(start_node)",
            "                reconst_path.reverse()",
            "                print('Path found: {}'.format(reconst_path))",
            "                return reconst_path"         ,
            "            for (m, weight) in self.get_neighbors(n):"        ,  
            "                if m not in open_list and m not in closed_list:",
            "                    open_list.add(m)",
            "                    parents[m] = n",
            "                    g[m] = g[n] + weight",
            "                else:",
            "                    if g[m] > g[n] + weight:",
            "                        g[m] = g[n] + weight",
            "                        parents[m] = n",
            "                        if m in closed_list:",
            "                            closed_list.remove(m)",
            "                            open_list.add(m)" ,
            "            open_list.remove(n)",
            "            closed_list.add(n)",
            "        print('Path does not exist!')",
            "        return None",
            "adjacency_list = {",
            "    'A': [('B', 1), ('C', 3), ('D', 7)],",
            "    'B': [('D', 5)],",
            "    'C': [('D', 12)]",
            "}",
            "graph1 = Graph(adjacency_list)",
            "graph1.a_star_algorithm('A', 'D')"
        ],
        "description": "A Star Algorithm"
    },
    // "Genetic Algorithm" :{
    //     "prefix": "!geneticalgorithm",
    //     "body": [
    //         "from random import randint",
    //         "def selection(li):",
    //         "dec = list(map(lambda x : int(x, 2), li))",
    //         "fit = list(map(lambda x : x*x, dec))",
    //         "s = sum(fit)",
    //         "prob = list(map(lambda x : round(x/s, 3), fit))",
    //         "avg = s/n",
    //         "exe = list(map(lambda x : round(x/avg, 3), fit))",
    //         "ac = list(map(lambda x : round(x), exe))",
    //         "return dec, fit, prob, exe, ac",
    //         "def pp(li, ac, n):",
    //         "co = []",
    //         "temp = []",
    //         "index = []",
    //         "for i in range(n):",
    //         "    if ac[i] == 1:",
    //         "    co.append(li[i])",
    //         "    elif ac[i] >= 2:",
    //         "    for j in range(ac[i] - 1):",
    //         "        temp.append(li[i])",
    //         "    co.append(li[i])",
    //         "    elif ac[i] == 0 and len(temp) != 0:",
    //         "    co.append(temp[0])",
    //         "    temp.pop(0)",
    //         "    elif ac[i] == 0 and len(temp) == 0:",
    //         "    index.append(i)",
    //         "if len(index) != 0 and len(temp) != 0:",
    //         "    for i in index:",
    //         "    co.insert(i, temp[0])",
    //         "    temp.pop(0)",
    //         "elif len(index) != 0 and len(temp) == 0:",
    //         "    co.insert(i, li[i])",
    //         "return co",
    //         "def cr(x):",
    //         "s = 0",
    //         "for i in x:",
    //         "    if i == '1':",
    //         "    s = s + 1",
    //         "return s",
    //         "def crossing(li, n):",
    //         "crossed = []",
    //         "for i in range(0, n, 2):",
    //         "    temp1 = li[i]",
    //         "    j = i + 1",
    //         "    temp2 = li[j]",
    //         "    crosspoint = cr(temp1)",
    //         "    print(\"The crosspoint for pair \" + str(i) + \" is \" + str(crosspoint))",
    //         "    temp3 = temp1[crosspoint: ]",
    //         "    temp4 = temp2[crosspoint: ]",
    //         "    temp1 = temp1[0 : crosspoint] + temp4",
    //         "    temp2 = temp2[0 : crosspoint] + temp3",
    //         "    crossed.append(temp1)",
    //         "    crossed.append(temp2)",
    //         "return crossed",
    //         "def mutation(li, n):",
    //         "mut = []",
    //         "for i in li:",
    //         "    j = randint(0, n - 1)",
    //         "    print(\"For pair \" + str(i) + \", the bit that will be changed is \" + str(j))",
    //         "    if i[j] == '1':",
    //         "    i = i[0 : j] + '0' +i[j + 1 : ]",
    //         "    mut.append(i)",
    //         "    elif i[j] == '0':",
    //         "    i = i[0 : j] + '1' +i[j + 1 : ]",
    //         "    mut.append(i)",
    //         "return mut",
    //         "n = int(input(\"Enter number of samples: \"))",
    //         "sam = []",
    //         "for i in range(n):",
    //         "sam.append(input(\"Enter gene: \"))",
    //         "m = int(input(\"Enter number of generations to be computed: \"))",
    //         "crossed = sam.copy()",
    //         "for i in range(m):",
    //         "dec, fit, prob, exe, ac = selection(crossed)",
    //         "s = sum(ac)",
    //         "if s < n:",
    //         "    maxi = max(ac)",
    //         "    k = ac.index(maxi - 1)",
    //         "    ac[k] += 1",
    //         "if s > n:",
    //         "    maxi = max(ac)",
    //         "    k = ac.index(maxi)",
    //         "    ac[k] -= 1",
    //         "print(\"\\n----------------------------------------------- GENERATION \", i, \"-----------------------------------------------\")",
    //         "print(\"Initial Population\\tX Value\\t\\tFitness Value\\tProbability\\tExpected Count\\t\\tActual Count\")",
    //         "for j in range(n):",
    //         "    print(crossed[j], \"\\t\\t\", dec[j], \"\\t\t\", fit[j], \"\\t\", prob[j], \"\\t\\t\", exe[j], \"\\t\\t\\t\", ac[j])",
    //         "co = pp(crossed, ac, n)",
    //         "print(\"\\nSelected Genes for Crossover - \\n\", co)",
    //         "crossed = crossing(co, n)",
    //         "print(\"\\nCrossover - \\n\", crossed)",
    //         "crossed = mutation(crossed, n)",
    //         "print(\"\\nMutated - \\n\", crossed)",
    //         "print(\"\\nGENERATION \", (m + 1), \" - \", crossed)"
    //     ],
    //     "description": "Genetic Algorithm"
    // },
    "Two Phase Python" :{
        "prefix": "!twophasepython",
        "body": [
            "#Server",
            "import socket",
            "def ServerSoc():",
            "    host = \"127.0.0.1\"",
            "    port = 8000",
            "    print(\"Server is running!\")",
            "    msg = \"PREPARE\"",
            "    log = msg",
            "    over = 0",
            "    s_soc = socket.socket()",
            "    s_soc.bind((host,port))",
            "    s_soc.listen(2)",
            "    while(1):",
            "        replies = []",
            "        print(f\"Coordinator : {msg.upper()}\")",
            "        for i in range(3):",
            "            conn,add = s_soc.accept()",
            "            conn.send(msg.encode())",
            "            data = conn.recv(1024).decode()",
            "            replies.append(data.upper())",
            "            print(f\"Subordinator {i} {add} : {data.upper()}\")",
            "        if over == 1:",
            "            break",
            "        if (\"ABORT\" in replies) or (len(replies)<3) :",
            "            msg = \"ABORT\"",
            "            print(\"TRANSACTION ABORTED!\\nThe final log is: \", log+\" \"+msg)",
            "            over = 1",
            "        elif \"SUCCESS\" in replies:",
            "            msg = \"COMPLETE\"",
            "            print(\"TRANSACTION COMPLETED!\\nThe final log is: \", log+\" \"+msg)",
            "            over = 1",
            "        else:",
            "            msg = \"COMMIT\"",
            "            log += \" \"+msg",
            "ServerSoc()",
            "#Client",
            "import socket",
            "def ClientSoc():",
            "    host = \"127.0.0.1\"",
            "    port = 8000",
            "    log = \"\"",
            "    over = 0",
            "    while(1):",
            "        try:",
            "            s_soc = socket.socket()",
            "            s_soc.connect((host,port))",
            "            rec_data = s_soc.recv(1024).decode()",
            "            print(\"Coordinator: \", rec_data.upper())",
            "            if rec_data.upper() == \"ABORT\":",
            "                msg = \"OK\"",
            "                print(\"TRANSACTION ABORTED!\")",
            "                over = 1",
            "            elif rec_data.upper() == \"SUCCESS\":",
            "                msg = \"OK\"",
            "                print(\"TRANSACTION COMPLETED!\")",
            "                over = 1",
            "            else:",
            "                msg = input(\"System Status: \").upper()",
            "                log += \" \"+msg",
            "                s_soc.send(msg.encode())",
            "            if over == 1:",
            "                break",
            "            s_soc.close()",
            "        except:",
            "            print(\"END OF TRANSACTION\\n final log is: \",log+\" \"+rec_data.upper())",
            "            break",
            "ClientSoc()"
        ],
        "description": "Two Phase Python"
    },
    "Three Phase Python" :{
        "prefix": "!threephasepython",
        "body": [
            "# Client",
            "import socket",
            "def ClientSoc():",
            "    host = \"127.0.0.1\"",
            "    port = 8000",
            "    log = \"\"",
            "    over = 0",
            "    while(1):",
            "        try:",
            "            s_soc = socket.socket()",
            "            s_soc.connect((host,port))",
            "            rec_data = s_soc.recv(1024).decode()",
            "            print(\"Coordinator: \", rec_data.upper())",
            "            if rec_data.upper() == \"FINAL ABORT\":",
            "                msg = \"OK\"",
            "                print(\"TRANSACTION ABORTED!\")",
            "                over = 1",
            "            elif rec_data.upper() == \"SUCCESS\":",
            "                msg = \"OK\"",
            "                print(\"TRANSACTION COMPLETED!\")",
            "                over = 1",
            "            else:",
            "                msg = input(\"System Status: \").upper()",
            "                log += \" \"+rec_data.upper()",
            "                s_soc.send(msg.encode())",
            "            if over == 1:",
            "                break",
            "            s_soc.close()",
            "        except:",
            "            print(\"END OF TRANSACTION\\n final log is: \",log+\" \"+rec_data.upper())",
            "            break",
            "ClientSoc()",
            "# Server",
            "import socket",
            "def ServerSoc():",
            "    host = \"127.0.0.1\"",
            "    port = 8000",
            "    print(\"Server is running!\")",
            "    msg = \"PREPARE\"",
            "    log = msg",
            "    over = 0",
            "    s_soc = socket.socket()",
            "    s_soc.bind((host,port))",
            "    s_soc.listen(2)",
            "    while(1):",
            "        replies = []",
            "        print(f\"Coordinator : {msg.upper()}\")",
            "        for i in range(3):",
            "            conn,add = s_soc.accept()",
            "            conn.send(msg.encode())",
            "            data = conn.recv(1024).decode()",
            "            replies.append(data.upper())",
            "            print(f\"Subordinator {i} {add} : {data.upper()}\")",
            "        if over == 2:",
            "            break",
            "        if (\"ABORT\" in replies) or (len(replies)<3) :",
            "            msg = \"PREPARE ABORT\"",
            "            over = 1",
            "        elif \"SUCCESS\" in replies:",
            "            msg = \"COMPLETE\"",
            "            print(\"TRANSACTION COMPLETED!\\nThe final log is: \", log+\" \"+msg)",
            "            over = 2",
            "        elif \"READY\" in replies:",
            "            msg = \"PREPARE COMMIT\"",
            "        else:",
            "            if over == 1:",
            "                msg = \"FINAL ABORT\"",
            "                over = 2",
            "            else:",
            "                msg =\"FINAL COMMIT\"",
            "                print(\"TRANSACTION ABORTED!\\nThe final log is: \", log+\" \"+msg)",
            "                log += \" \"+msg",
            "ServerSoc()"
        ],
        "description": "Three Phase Python"
    },
    "XML ADBMS" :{
        "prefix": "!threephasepython",
        "body": [
            "# XML",
            "<?xml version=\"1.0\"?>",
            "<catalog>",
            "<book id=\"bk101\">",
            "    <author>Gambardella, Matthew</author>",
            "    <title>XML Developer's Guide</title>",
            "    <genre>Computer</genre>",
            "    <price>44.95</price>",
            "    <publish_date>2000-10-01</publish_date>",
            "    <description>An in-depth look at creating applications",
            "    with XML.</description>",
            "</book>",
            "<book id=\"bk102\">",
            "    <author>Ralls, Kim</author>",
            "    <title>Midnight Rain</title>",
            "    <genre>Fantasy</genre>",
            "    <price>5.95</price>",
            "    <publish_date>2000-12-16</publish_date>",
            "    <description>A former architect battles corporate zombies,",
            "    an evil sorceress, and her own childhood to become queen",
            "    of the world.</description>",
            "</book>",
            "<book id=\"bk103\">",
            "    <author>Corets, Eva</author>",
            "    <title>Maeve Ascendant</title>",
            "    <genre>Fantasy</genre>",
            "    <price>5.95</price>",
            "    <publish_date>2000-11-17</publish_date>",
            "    <description>After the collapse of a nanotechnology",
            "    society in England, the young survivors lay the",
            "    foundation for a new society.</description>",
            "</book>",
            "<book id=\"bk104\">",
            "    <author>Corets, Eva</author>",
            "    <title>Oberon's Legacy</title>",
            "    <genre>Fantasy</genre>",
            "    <price>5.95</price>",
            "    <publish_date>2001-03-10</publish_date>",
            "    <description>In post-apocalypse England, the mysterious",
            "    agent known only as Oberon helps to create a new life",
            "    for the inhabitants of London. Sequel to Maeve",
            "    Ascendant.</description>",
            "</book>",
            "<book id=\"bk105\">",
            "    <author>Corets, Eva</author>",
            "    <title>The Sundered Grail</title>",
            "    <genre>Fantasy</genre>",
            "    <price>5.95</price>",
            "    <publish_date>2001-09-10</publish_date>",
            "    <description>The two daughters of Maeve, half-sisters,",
            "    battle one another for control of England. Sequel to",
            "    Oberon's Legacy.</description>",
            "</book>",
            "<book id=\"bk106\">",
            "    <author>Randall, Cynthia</author>",
            "    <title>Lover Birds</title>",
            "    <genre>Romance</genre>",
            "    <price>4.95</price>",
            "    <publish_date>2000-09-02</publish_date>",
            "    <description>When Carla meets Paul at an ornithology",
            "    conference, tempers fly as feathers get ruffled.</description>",
            "</book>",
            "<book id=\"bk107\">",
            "    <author>Thurman, Paula</author>",
            "    <title>Splish Splash</title>",
            "    <genre>Romance</genre>",
            "    <price>4.95</price>",
            "    <publish_date>2000-11-02</publish_date>",
            "    <description>A deep sea diver finds true love twenty",
            "    thousand leagues beneath the sea.</description>",
            "</book>",
            "<book id=\"bk108\">",
            "    <author>Knorr, Stefan</author>",
            "    <title>Creepy Crawlies</title>",
            "    <genre>Horror</genre>",
            "    <price>4.95</price>",
            "    <publish_date>2000-12-06</publish_date>",
            "    <description>An anthology of horror stories about roaches,",
            "    centipedes, scorpions  and other insects.</description>",
            "</book>",
            "<book id=\"bk109\">",
            "    <author>Kress, Peter</author>",
            "    <title>Paradox Lost</title>",
            "    <genre>Science Fiction</genre>",
            "    <price>6.95</price>",
            "    <publish_date>2000-11-02</publish_date>",
            "    <description>After an inadvertant trip through a Heisenberg",
            "    Uncertainty Device, James Salway discovers the problems",
            "    of being quantum.</description>",
            "</book>",
            "<book id=\"bk110\">",
            "    <author>O'Brien, Tim</author>",
            "    <title>Microsoft .NET: The Programming Bible</title>",
            "    <genre>Computer</genre>",
            "    <price>36.95</price>",
            "    <publish_date>2000-12-09</publish_date>",
            "    <description>Microsoft's .NET initiative is explored in",
            "    detail in this deep programmer's reference.</description>",
            "</book>",
            "<book id=\"bk111\">",
            "    <author>O'Brien, Tim</author>",
            "    <title>MSXML3: A Comprehensive Guide</title>",
            "    <genre>Computer</genre>",
            "    <price>36.95</price>",
            "    <publish_date>2000-12-01</publish_date>",
            "    <description>The Microsoft MSXML3 parser is covered in",
            "    detail, with attention to XML DOM interfaces, XSLT processing,",
            "    SAX and more.</description>",
            "</book>",
            "<book id=\"bk112\">",
            "    <author>Galos, Mike</author>",
            "    <title>Visual Studio 7: A Comprehensive Guide</title>",
            "    <genre>Computer</genre>",
            "    <price>49.95</price>",
            "    <publish_date>2001-04-16</publish_date>",
            "    <description>Microsoft Visual Studio 7 is explored in depth,",
            "    looking at how Visual Basic, Visual C++, C#, and ASP+ are",
            "    integrated into a comprehensive development",
            "    environment.</description>",
            "</book>",
            "</catalog>",
            "# HTML",
            "<!DOCTYPE html>",
            "<html lang=\"en\">",
            "<head>",
            "    <meta charset=\"UTF-8\">",
            "    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">",
            "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">",
            "    <title>XML</title>",
            "</head>",
            "<body>",
            "    <button type=\"button\" onclick=\"loadXMLDoc()\">View Information about the Books</button>",
            "    <book></book>",
            "    <table id=\"data-table\"></table>",
            "    <script>",
            "        function loadXMLDoc() {",
            "            var xmlhttp = new XMLHttpRequest();",
            "            xmlhttp.onreadystatechange = function () {",
            "                if (this.readyState == 4 && this.status == 200) {",
            "                    myFunction(this);",
            "                }",
            "            };",
            "            xmlhttp.open(\"GET\", \"test.xml\", true);",
            "            xmlhttp.send();",
            "        }",
            "        function myFunction(xml) {   ",
            "            var i;",
            "            var xmlDoc = xml.responseXML;",
            "            var table = \"<tr><th>Title</th><th>Author</th><th>Genre</th><th>Price</th><th>Publish Date</th><th>Description</th></tr>\";",
            "            var x = xmlDoc.getElementsByTagName(\"book\");",
            "            for (i = 0; i < x.length; i++) {",
            "                table += \"<tr><td>\" +",
            "                    x[i].getElementsByTagName(\"title\")[0].childNodes[0].nodeValue +",
            "                    \"</td><td>\" +",
            "                    x[i].getElementsByTagName(\"author\")[0].childNodes[0].nodeValue +",
            "                    \"</td><td>\" +",
            "                    x[i].getElementsByTagName(\"genre\")[0].childNodes[0].nodeValue +",
            "                    \"</td><td>\" +",
            "                    x[i].getElementsByTagName(\"price\")[0].childNodes[0].nodeValue +",
            "                    \"</td><td>\" +",
            "                    x[i].getElementsByTagName(\"publish_date\")[0].childNodes[0].nodeValue +",
            "                    \"</td><td>\" +",
            "                    x[i].getElementsByTagName(\"description\")[0].childNodes[0].nodeValue +",
            "                    \"</td></tr>\";",
            "            }",
            "            document.getElementById(\"data-table\").innerHTML = table;",
            "        }",
            "    </script>",
            "</body>",
            "</html>"
        ],
        "description": "XML ADBMS"
    },
    "DFID Algorithm" :{
        "prefix": "!dfidalgorithm",
        "body": [
            "from collections import defaultdict",
            "class Graph:",
            "    def __init__(self,vertices):",
            "        self.V = vertices" ,
            "        self.graph = defaultdict(list)",
            "    def addEdge(self,u,v):",
            "        self.graph[u].append(v)",
            "    def DLS(self,src,target,maxDepth):",
            "        if src == target : return True",
            "        if maxDepth <= 0 : return False",
            "        for i in self.graph[src]:",
            "                if(self.DLS(i,target,maxDepth-1)):",
            "                    return True",
            "        return False" ,
            "    def IDDFS(self,src, target, maxDepth):",
            "        for i in range(maxDepth):",
            "            if (self.DLS(src, target, i)):",
            "                return True",
            "        return False",
            "g = Graph (7)",
            "g.addEdge(0, 1)",
            "g.addEdge(0, 2)",
            "g.addEdge(1, 3)",
            "g.addEdge(1, 4)",
            "g.addEdge(2, 5)",
            "g.addEdge(2, 6)",
            "for i in range(2):",
            "    target = [5, 3]; maxDepth = [3,2]; src = 0",
            "    if g.IDDFS(src, target[i], maxDepth[i]) == True:",
            "        print (\"Target \"+str(target[i]) +\" is reachable from source within max depth of \"+str(maxDepth[i]))",
            "    else :",
            "        print (\"Target \"+str(target[i]) +\" is NOT reachable from source within max depth of \"+str(maxDepth[i]))"

        ],
        "description": "DFID Algorithm"
    },
    "Genetic Algorithm" :{
        "prefix": "!geneticalgorithm",
        "body": [
            "from random import randint",
            "def selection(li):",
            "dec = list(map(lambda x : int(x, 2), li))",
            "fit = list(map(lambda x : x*x, dec))",
            "s = sum(fit)",
            "prob = list(map(lambda x : round(x/s, 3), fit))",
            "avg = s/n",
            "exe = list(map(lambda x : round(x/avg, 3), fit))",
            "ac = list(map(lambda x : round(x), exe))",
            "return dec, fit, prob, exe, ac",
            "def pp(li, ac, n):",
            "co = []",
            "temp = []",
            "index = []",
            "for i in range(n):",
            "    if ac[i] == 1:",
            "    co.append(li[i])",
            "    elif ac[i] >= 2:",
            "    for j in range(ac[i] - 1):",
            "        temp.append(li[i])",
            "    co.append(li[i])",
            "    elif ac[i] == 0 and len(temp) != 0:",
            "    co.append(temp[0])",
            "    temp.pop(0)",
            "    elif ac[i] == 0 and len(temp) == 0:",
            "    index.append(i)",
            "if len(index) != 0 and len(temp) != 0:",
            "    for i in index:",
            "    co.insert(i, temp[0])",
            "    temp.pop(0)",
            "elif len(index) != 0 and len(temp) == 0:",
            "    co.insert(i, li[i])",
            "return co",
            "def cr(x):",
            "s = 0",
            "for i in x:",
            "    if i == '1':",
            "    s = s + 1",
            "return s",
            "def crossing(li, n):",
            "crossed = []",
            "for i in range(0, n, 2):",
            "    temp1 = li[i]",
            "    j = i + 1",
            "    temp2 = li[j]",
            "    crosspoint = cr(temp1)",
            "    print(\"The crosspoint for pair \" + str(i) + \" is \" + str(crosspoint))",
            "    temp3 = temp1[crosspoint: ]",
            "    temp4 = temp2[crosspoint: ]",
            "    temp1 = temp1[0 : crosspoint] + temp4",
            "    temp2 = temp2[0 : crosspoint] + temp3",
            "    crossed.append(temp1)",
            "    crossed.append(temp2)",
            "return crossed",
            "def mutation(li, n):",
            "mut = []",
            "for i in li:",
            "    j = randint(0, n - 1)",
            "    print(\"For pair \" + str(i) + \", the bit that will be changed is \" + str(j))",
            "    if i[j] == '1':",
            "    i = i[0 : j] + '0' +i[j + 1 : ]",
            "    mut.append(i)",
            "    elif i[j] == '0':",
            "    i = i[0 : j] + '1' +i[j + 1 : ]",
            "    mut.append(i)",
            "return mut",
            "n = int(input(\"Enter number of samples: \"))",
            "sam = []",
            "for i in range(n):",
            "sam.append(input(\"Enter gene: \"))",
            "m = int(input(\"Enter number of generations to be computed: \"))",
            "crossed = sam.copy()",
            "for i in range(m):",
            "dec, fit, prob, exe, ac = selection(crossed)",
            "s = sum(ac)",
            "if s < n:",
            "    maxi = max(ac)",
            "    k = ac.index(maxi - 1)",
            "    ac[k] += 1",
            "if s > n:",
            "    maxi = max(ac)",
            "    k = ac.index(maxi)",
            "    ac[k] -= 1",
            "print(\"\\n----------------------------------------------- GENERATION \", i, \"-----------------------------------------------\")",
            "print(\"Initial Population\\tX Value\\t\\tFitness Value\\tProbability\\tExpected Count\\t\\tActual Count\")",
            "for j in range(n):",
            "    print(crossed[j], \"\\t\\t\", dec[j], \"\\t\\t\", fit[j], \"\\t\", prob[j], \"\\t\\t\", exe[j], \"\\t\\t\\t\", ac[j])",
            "co = pp(crossed, ac, n)",
            "print(\"\\nSelected Genes for Crossover - \\n\", co)",
            "crossed = crossing(co, n)",
            "print(\"\\nCrossover - \\n\", crossed)",
            "crossed = mutation(crossed, n)",
            "print(\"\\nMutated - \\n\", crossed)",
            "print(\"\\nGENERATION \", (m + 1), \" - \", crossed)"
        ],
        "description": "Genetic Algorithm"
    },
    "Prologue family tree" :{
        "prefix": "!dfidalgorithm",
        "body": [
            "male(jack).",
            "male(oliver).",
            "male(ali).",
            "male(james).",
            "male(simon).",
            "male(harry).",
            "female(helen).",
            "female(sophie).",
            "female(jess).",
            "female(lily).",
            "parent_of(jack,jess).",
            "parent_of(jack,lily).",
            "parent_of(helen, jess).",
            "parent_of(helen, lily).",
            "parent_of(oliver,james).",
            "parent_of(sophie, james).",
            "parent_of(jess, simon).",
            "parent_of(ali, simon).",
            "parent_of(lily, harry).",
            "parent_of(james, harry).",
            "/* Rules */",
            "father_of(X,Y):- male(X),",
            "    parent_of(X,Y).",
            "mother_of(X,Y):- female(X),",
            "    parent_of(X,Y).",
            "grandfather_of(X,Y):- male(X),",
            "    parent_of(X,Z),",
            "    parent_of(Z,Y).",
            "grandmother_of(X,Y):- female(X),",
            "    parent_of(X,Z),",
            "    parent_of(Z,Y).",
            "sister_of(X,Y):- %(X,Y or Y,X)%",
            "    female(X),",
            "    father_of(F, Y), father_of(F,X),X \\= Y.",
            "sister_of(X,Y):- female(X),",
            "    mother_of(M, Y), mother_of(M,X),X \\= Y.",
            "aunt_of(X,Y):- female(X),",
            "    parent_of(Z,Y), sister_of(Z,X),!.",
            "brother_of(X,Y):- %(X,Y or Y,X)%",
            "    male(X),",
            "    father_of(F, Y), father_of(F,X),X \\= Y.",
            "brother_of(X,Y):- male(X),",
            "    mother_of(M, Y), mother_of(M,X),X \\= Y.",
            "uncle_of(X,Y):-",
            "    parent_of(Z,Y), brother_of(Z,X).",
            "ancestor_of(X,Y):- parent_of(X,Y).",
            "ancestor_of(X,Y):- parent_of(X,Z),",
            "    ancestor_of(Z,Y)."
        ],
        "description": "Prologue family tree"
    },
}