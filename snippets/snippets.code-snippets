{
    "Genetic Algorithm Starter Template":{
        "prefix": "!geneticAlgo",
        "body" : [
            "import numpy",
            "genes = 2",
            "chromosomes = 10",
            "mattingPoolSize = 6",
            "offspringSize = chromosomes - mattingPoolSize",
            "lb = -5",
            "ub = 5",
            "populationSize = (chromosomes, genes)",
            "generations = 3",
            "population = numpy.random.uniform(lb, ub, populationSize)",
            "for generation in range(generations):",
            "    print((\"Generation:\", generation+1))",
            "    fitness = numpy.sum(population*population, axis=1)",
            "    print(\"\\npopulation\")",
            "    print(population)",
            "    print(\"\\nfitness calcuation\")",
            "    print(fitness)",
            "    parents = numpy.empty((mattingPoolSize, population.shape[1]))",
            "    for p in range(mattingPoolSize):",
            "       fittestIndex = numpy.where(fitness == numpy.max(fitness))",
            "       fittestIndex = fittestIndex[0][0]",
            "       parents[p, :] = population[fittestIndex, :]",
            "       fitness[fittestIndex] = -1",
            "       print(\"\\nParents:\")",
            "       print(parents)",
            "       offspring = numpy.empty((offspringSize, population.shape[1]))",
            "    for k in range(offspringSize):",
            "       crossoverPoint = numpy.random.randint(0,genes)",
            "       parent1Index = k%parents.shape[0]",
            "       parent2Index = (k+1)%parents.shape[0]",
            "       offspring[k, 0: crossoverPoint] = parents[parent1Index, 0: crossoverPoint]",
            "       offspring[k, crossoverPoint:] = parents[parent2Index, crossoverPoint:]",
            "    print(\"\\nOffspring after crossover:\")",
            "    print(offspring)",
            "    for index in range(offspring.shape[0]):",
            "       randomIndex = numpy.random.randint(1,genes)",
            "       randomValue = numpy.random.uniform(lb, ub, 1)",
            "       offspring [index, randomIndex] = offspring [index, randomIndex] + randomValue",
            "    print(\"\\n Offspring after Mutation\")",
            "    print(offspring)",
            "    population[0:parents.shape[0], :] = parents",
            "    population[parents.shape[0]:, :] = offspring",
            "    print(\"\\nNew Population for next generation:\")",
            "    print(population)",
            "fitness = numpy.sum(population*population, axis=1)",
            "fittestIndex = numpy.where(fitness == numpy.max(fitness))",
            "fittestIndex = fittestIndex[0][0]",
            "fittestInd = population[fittestIndex, :]",
            "bestFitness = fitness[fittestIndex]",
            "print(\"\\nBest Individual:\")",
            "print(fittestInd)",
            "print(\"\\nBest Individual's Fitness:\")",
            "print(bestFitness)"            
        ],
        "description": "Genetic Algorithm Starter Template"
    },
    "Descending order Assembly Language":{
        "prefix": "!descendingOrder",
        "body": [
            "MOV SI,1100H",
            "MOV CL,[SI]",
            "DEC CL",
            "REPEAT:",
            "MOV SI,1100H",
            "MOV CH,[SI]",
            "DEC CH",
            "INC SI",
            "RECOMP:",
            "MOV AL,[SI]",
            "INC SI",
            "CMP AL,[SI]",
            "JNC AHEAD"  ,              
            "XCHG AL,[SI]",
            "XCHG AL,[SI-1]",
            "AHEAD:",
            "DEC CH",
            "JNZ RECOMP",
            "DEC CL",
            "JNZ REPEAT",
            "HLT"  
        ],
        "description": "Descending order Assembly Language"
    },
    "Ascending order Assembly Language":{
        "prefix": "!ascendingOrder",
        "body": [
            "MOV SI,1100H",
            "MOV CL,[SI]",
            "DEC CL",
            "REPEAT:",
            "MOV SI,1100H",
            "MOV CH,[SI]",
            "DEC CH",
            "INC SI",
            "RECOMP:",
            "MOV AL,[SI]",
            "INC SI",
            "CMP AL,[SI]",
            "JC AHEAD",
            "XCHG AL,[SI]",
            "XCHG AL,[SI-1]",
            "AHEAD:",
            "DEC CH",
            "JNZ RECOMP",
            "DEC CL",
            "JNZ REPEAT",
            "HLT"
        ],
        "description": "Ascending order Assembly Language"
    },
    "Shortest Number Assembly Language":{
        "prefix": "!shortestNumber",
        "body": [
            "MOV SI,1100H",
            "MOV DI,1200H",
            "MOV CL,[SI]",
            "INC SI",
            "MOV AL,[SI]",
            "DEC CL",
            "AGAIN:",
            "INC SI",
            "MOV BL,[SI]",
            "CMP AL,BL",
            "JC AHEAD",         
            "MOV AL,BL",
            "AHEAD:",
            "DEC CL",
            "JNZ AGAIN",
            "MOV [DI],AL",
            "HLT"   
        ],
        "description": "Shortest Number Assembly Language"
    },
    "Largest Number Assembly Language":{
        "prefix": "!largestNumber",
        "body": [
            "MOV SI,1100H",
            "MOV DI,1200H",
            "MOV CL,[SI]",
            "INC SI",
            "MOV AL,[SI]",
            "DEC CL",
            "AGAIN:",
            "INC SI",
            "MOV BL,[SI]",
            "CMP AL,BL",
            "JNC AHEAD",
            "MOV AL,BL",
            "AHEAD:",
            "DEC CL",
            "JNZ AGAIN",
            "MOV [DI],AL",
            "HLT"
        ],
        "description": "Largest Number Assembly Language"
    },
    "Factorial without macros":{
        "prefix": "!factorialwithoutmacros",
        "body": [
            "DATA SEGMENT",
            "A DB 5",
            "fact DB ?",
            "DATA ENDS",
            "CODE SEGMENT",
            "         ASSUME DS:DATA,CS:CODE",
            "START:",
            "      MOV AX,DATA",
            "      MOV DS,AX",
            "      MOV AH,00",
            "      MOV AL,A",
            " L1:  DEC A",
            "      MUL A",
            "      MOV CL,A",
            "      CMP CL,01",
            "      JNZ L1",
            "      MOV fact, AL",
            "CODE ENDS",
            "END START"
            
        ],
        "description": "Factorial without macros"
    },
    "Factorial using macros":{
        "prefix": "!factorialwithmacros",
        "body": [
            "fact macro f",
            "    up:",
            "    mul f",
            "    dec f",
            "    jnz up",
            "endm",
            "data segment",
            "    num dw 05h",
            "    result dw ?",
            "ends",
            "stack segment",
            "    dw 128 dup(0)",
            "ends",
            "code segment",
            "    start:",
            "    mov ax,data",
            "    mov ds,ax",
            "    mov cx,num",
            "    mov ax, 0001h",
            "    fact num",
            "    mov result,ax",
            "ends"
        ],
        "description": "Factorial using macros"
    },
    "Python Gui":{
        "prefix": "!pythongui",
        "body": [
            "import tkinter as tk",
            "from tkinter import *",
            "root = tk.Tk()",
            "root.geometry('350x200')",
            "root.title('Login Form')",
            "label1 = tk.Label(root, text='Username: ')",
            "label1.grid()",
            "label2 = tk.Label(root, text='Password: ')",
            "print(type(label1))",
            "label2.grid()",
            "Username = tk.Entry(root, width=20)",
            "Password = tk.Entry(root, width=20)",
            "Username.grid(row=0, column=1)",
            "Password.grid(row=1, column=1)",
            "def SubmitForm(Username, Password):",
            "    user_list = []",
            "    pass_list = []",
            "    if Username not in user_list and Password not in pass_list:",
            "        user_list.append(Username)",
            "        pass_list.append(Password)",
            "        next_window = Toplevel(root)",
            "        next_window.geometry('350x200')",
            "        next_window.title('Showing User Details')",
            "        label5 = tk.Label(next_window, text='Username:')",
            "        label5.grid(row=0, column=0)",
            "        label6 = tk.Label(next_window, text='Password:')",
            "        label6.grid(row=1, column=0)",
            "        label3 = tk.Label(next_window, text=Username)",
            "        label3.grid(row=0, column=1)",
            "        label4 = tk.Label(next_window, text=Password)",
            "        label4.grid(row=1, column=1)",
            "def print_details():",
            "    Uss = Username.get()",
            "    passw = Password.get()",
            "    SubmitForm(Uss, passw)",
            "Button = tk.Button(root, text='Click for Submit', command=print_details)",
            "Button.grid(row=2, column=1)",
            "root.mainloop()"      
            
        ],
        "description": "Python Gui"
    },
    "Addition in assembly language":{
        "prefix": "!additionAssembly",
        "body": [
            "MOV AX,[1000H]",
            "MOV BX,[1002H]",
            "MOV CL,00H",
            "ADD AX,BX",
            "MOV [1004H],AX",
            "JNC JUMP",
            "INC CL",
            "JUMP:",
            "MOV [1006H],CL",
            "HLT"
        ],
        "description": "Addition in assembly language"        
    },
    "Subtraction in assembly language":{
        "prefix": "!subtractionAssembly",
        "body": [
            "MOV AX,[1000H]",
            "MOV BX,[1002H]",
            "MOV CL,00H",
            "SUB AX,BX",
            "JNC JUMP",
            "INC CL",
            "NOT AX",
            "ADD AX,0001H",
            "JUMP:",
            "MOV [1004H],AX",
            "MOV [1006H],CL",
            "HLT"         
        ],
        "description": "Subtraction in assembly language"        
    },
    "Multiplication in assembly language":{
        "prefix": "!multiplicationAssembly",
        "body": [
            "MOV SI,1100H",
            "MOV AX,[SI]",
            "MOV BX,[SI+2]",
            "MUL BX",
            "MOV [SI+4],AX",
            "MOV [SI+6],DX",
            "HLT"              
        ],
        "description": "Multiplication in assembly language"        
    },
    "Division in assembly language":{
        "prefix": "!divisionAssembly",
        "body": [
            "MOV SI,1100H",
            "MOV AX,[SI]",
            "MOV BX,[SI+2]",
            "DIV BX",
            "MOV [SI+6],AX",
            "MOV [SI+8],DX",
            "HLT"              
        ],
        "description": "Division in assembly language"        
    },
    "Simple Interest In Assembly Language":{
        "prefix": "!simpleInterestAssembly",
        "body": [
            "#include<stdio.h>",
            "#include<conio.h>",
            "#include<string.h>",
            "void main()",
            "{",
            "    int p, r, t, result, i,j;",
            "    clrscr();",
            "    printf(\"Enter Principal amount:\");",
            "    scanf(\"%d\",&p);",
            "    printf(\"Enter Rate of Interest:\");",
            "    scanf(\"%d\",&r);",
            "    printf(\"Enter Total time(in months):\");",
            "    scanf(\"%d\",&t);",
            "    asm mov ax,p;",
            "    asm mov bx,r;",
            "    asm mul bx;" ,
            "    asm mul t;",
            "    asm mov result,ax;",
            "    printf(\"Simple Interest:%d\\n\",result/100);",
            "    getch();",
            "}"
        ],
        "description": "Simple Interest In Assembly Language"        
    },
    "ExchangeDataSegment":{
        "prefix": "!exchangeDataSegment",
        "body": [
            "data segment",
            "src db 0x90, 0x34, 0x45, 0x21",
            "data ends",
            "extra segment ",
            "dest db ?",
            "extra ends",
            "code segment",
            "assume cs:code, ds:data, es:extra",
            "start:",
            "mov ax, data",
            "mov ds, ax",
            "mov ax, extra",
            "mov es, ax",
            "lea si, src",
            "lea di, dest",
            "mov cx, 0x04",
            "cld",
            "rep",
            "movsb",
            "end start",
            "code ends",
        ],
        "description": "ExchangeDataSegment"        
    },
    "Worst Fit Algorithm": {
        "prefix": "!worstfitpython",
        "body": [
            "def worstFit(blockSize, m, processSize, n):",
            "    allocation = [-1] * n",
            "    for i in range(n):",
            "        wstIdx = -1",
            "        for j in range(m):",
            "            if blockSize[j] >= processSize[i]:",
            "                if wstIdx == -1:",
            "                    wstIdx = j",
            "                elif blockSize[wstIdx] < blockSize[j]:",
            "                    wstIdx = j",
            "        if wstIdx != -1:",
            "            allocation[i] = wstIdx",
            "            blockSize[wstIdx] -= processSize[i]",
            "    print(\"Process No. Process Size Block no.\")",
            "    for i in range(n):",
            "        print(i + 1, \"         \", processSize[i], end = \"     \")",
            "        if allocation[i] != -1:",
            "            print(allocation[i] + 1)",
            "        else:",
            "            print(\"Not Allocated\")",
            "if __name__ == '__main__':",
            "    blockSize = [100, 500, 200, 300, 600]",
            "    processSize = [212, 417, 112, 426]",
            "    m = len(blockSize)",
            "    n = len(processSize)",
            "    worstFit(blockSize, m, processSize, n)",
        ],
        "description": "Worst Fit Algorithm" 
    },
    "First Fit Algorithm": {
        "prefix": "!firstfitpython",
        "body": [
            "def firstFit(blockSize, m, processSize, n):",
            "    allocation = [-1] * n",
            "    for i in range(n):",
            "        for j in range(m):",
            "            if blockSize[j] >= processSize[i]:",
            "                allocation[i] = j",
            "                blockSize[j] -= processSize[i]",
            "                break",
            "    print(\"Process No. Process Size      Block no.\")",
            "    for i in range(n):",
            "        print(\" \", i + 1, \"         \", processSize[i],\"         \", end = \" \")",
            "        if allocation[i] != -1:",
            "            print(allocation[i] + 1)",
            "        else:",
            "            print(\"Not Allocated\")",
            "if __name__ == '__main__':",
            "    blockSize = [100, 500, 200, 300, 600]",
            "    processSize = [212, 417, 112, 426]",
            "    m = len(blockSize)",
            "    n = len(processSize)",
            "    firstFit(blockSize, m, processSize, n)",
        ],
        "description": "First Fit Algorithm" 
    },
    "Best Fit Algorithm": {
        "prefix": "!bestfitpython",
        "body": [
            "def bestFit(blockSize, m, processSize, n):",
            "    allocation = [-1] * n",
            "    for i in range(n):",
            "        bestIdx = -1",
            "        for j in range(m):",
            "            if blockSize[j] >= processSize[i]:",
            "                if bestIdx == -1:",
            "                    bestIdx = j",
            "                elif blockSize[bestIdx] > blockSize[j]:",
            "                    bestIdx = j",
            "        if bestIdx != -1:",
            "            allocation[i] = bestIdx",
            "            blockSize[bestIdx] -= processSize[i]",
            "    print(\"Process No. Process Size      Block no.\")",
            "    for i in range(n):",
            "        print(i + 1, \"         \", processSize[i], end = \"     \")",
            "        if allocation[i] != -1:",
            "            print(allocation[i] + 1)",
            "        else:",
            "            print(\"Not Allocated\")",
            "if __name__ == '__main__':",
            "    blockSize = [100, 500, 200, 300, 600]",
            "    processSize = [212, 417, 112, 426]",
            "    m = len(blockSize)",
            "    n = len(processSize)",
            "    bestFit(blockSize, m, processSize, n)",
        ],
        "description": "Best Fit Algorithm" 
    },
    "Next Fit Algorithm": {
        "prefix": "!nextfitpython",
        "body": [
            "def NextFit(blockSize, m, processSize, n):",
            "    allocation = [-1] * n",
            "    j = 0",
            "    t = m-1",
            "    for i in range(n):",
            "        while j < m:",
            "            if blockSize[j] >= processSize[i]:",
            "                allocation[i] = j",
            "                blockSize[j] -= processSize[i]",
            "                t = (j - 1) % m",
            "                break",
            "            if t == j:",
            "                t = (j - 1) % m",
            "                break",
            "            j = (j + 1) % m",
            "    print(\"Process No. Process Size Block no.\")" ,
            "    for i in range(n):",
            "        print(i + 1, \"\\t\\t\", processSize[i],end = \"\\t \")",
            "        if allocation[i] != -1:",
            "            print(allocation[i] + 1)",
            "        else:",
            "            print(\"Not Allocated\")",
            "if __name__ == '__main__':",
            "    blockSize = [5, 10, 20]",
            "    processSize = [10, 20, 5]",
            "    m = len(blockSize)",
            "    n = len(processSize)",
            "    NextFit(blockSize, m, processSize, n)"
        ],
        "description": "Next Fit Algorithm" 
    },
    "Python Regex" : {
        "prefix": "!regexpython",
        "body": [
            "import re",
            "tp = open('myfile.txt', 'r')",
            "mail = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'",
            "number = r'\\S[^a-zA-Z\\n]+\\d+\\S[^a-zA-Z\\n]'",
            "sitee = r\"(http|https)://[\\w\\-]+(\\.[\\w\\-]+)+\\S*\"",
            "name = r'Mr.+|Mrs.+'",
            "m = tp.read()",
            "m = m.split('\\n')",
            "mails = []",
            "numbers = []",
            "names = []",
            "for i in m:",
            "    if (re.match(mail, i)):",
            "        mails.append(i)",
            "    elif re.match(number, i):",
            "        numbers.append(i)",
            "    elif re.match(name, i):",
            "        names.append(i)",
            "print(\"Mails :\",mails,\"\\nNumbers:\", numbers,\"\\nNames:\", names,\"\\n\")",
        ],
        "description": "Python Regex"         
    },
    "Python Inheritance":{
        "prefix": "!inheritancepython",
        "body": [
            "class Employee:",
            "    def __init__(self,id,name,Type):",
            "        self.id = id",
            "        self.name = name",
            "        self.Type = Type",
            "class Manager(Employee):",
            "    def __init__(self, id, name):",
            "        super().__init__(id, name, Type=\"Manger\")",
            "        self.MangerID = 100*id+id",
            "        self.testers=[]",
            "        self.developers=[]",
            "    def add_tester(self,id):",
            "        self.testers.append(id)",
            "    def remove_tester(self,id):",
            "        self.testers.remove(id)",
            "    def add_developer(self,id):",
            "        self.developers.append(id)",
            "    def remove_developer(self,id):",
            "        self.developers.remove(id)",
            "class Tester(Employee):",
            "    def __init__(self, id, name):",
            "        super().__init__(id, name, Type=\"Tester\")",
            "        self.TesterID = 100*id+id",
            "class Developer(Employee):",
            "    def __init__(self, id, name):",
            "        super().__init__(id, name, Type=\"Developer\")",
            "        self.DeveloperID = 100*id+id",
            "m1 = Manager(1,\"Rohan\")",
            "m2 = Manager(1,\"Raj\")",
            "t1 = Tester(2,\"Tester1\")",
            "t2 = Tester(3,\"Tester2\")",
            "d1 = Developer(4,\"dev\")",
            "m1.add_developer(d1.id)",
            "m1.add_tester(t1.id)",
            "m2.add_tester(t2.id)",
            "print(f\"For Manger 1:\\nTester:{m1.testers}\\nDevelopers:{m1.developers}\")",
            "print(f\"For Manger 2:\\nTester:{m2.testers}\\nDevelopers:{m2.developers}\")"

        ],
        "description": "Python Inheritance" 
    },
    "Client Server Python" : {
        "prefix": "!clientserverpython",
        "body": [
            "#Client",
            "import socket",
            "def mpm():",
            "    host = '127.0.0.1'",
            "    port = 6000",
            "    s = socket.socket()",
            "    s.connect((host, port))" , 
            "    while True:",
            "        x = input(\"Enter New Message : \")",
            "        y = x.encode('ascii')",
            "        s.send(y)",
            "        data = s.recv(1024)",
            "        d = data.decode('ascii')",
            "        print(\"Server: \",d)", 
            "mpm()",
            "#Sever",
            "import socket",
            "def mpm():",
            "    host = '127.0.0.1'",
            "    port = 6000",
            "    s = socket.socket()",
            "    s.bind((host, port))",
            "    s.listen(1)",
            "    c, addr = s.accept()" ,  
            "    print(\"Client Address : \", addr)" , 
            "    while True:",
            "        data = c.recv(1024)",
            "        d = data.decode('ascii')",
            "        print(\"Client: \", d)",
            "        x = input(\">>> \")",
            "        y = x.encode('ascii')",
            "        c.send(y)",
            "mpm()"
        ],
        "description": "Client Server Python" 
    },
    "Restoring Division" : {
        "prefix": "!restoringdivision",
        "body": [
            "def decimalToBinary(n):",
            "    return bin(n).replace(\"0b\", \"\")",
            "def add(A, M):",
            "    carry = 0",
            "    add_sum = ''",            
            "    for i in range(len(A) - 1, -1, -1):",
            "        temp = int(A[i]) + int(M[i]) + carry",
            "        if (temp > 1):",
            "            add_sum += str(temp % 2)",
            "            carry = 1",
            "        else:",
            "            add_sum += str(temp)",
            "            carry = 0",
            "    return add_sum[::-1]",     
            "def compliment(m):",
            "    M = ''",
            "    for i in range(0, len(m)):",
            "        M += str((int(m[i]) + 1) % 2)"      , 
            "    M = add(M, '0' * (len(M) - 1) + '1')",
            "    return M"         ,
            "def restoringDivision(Q, M, A):",
            "    count = len(M)",
            "    print(f'Initial Values: A: {A}, Q: {Q}, M: {M}')",
            "    while(count):",
            "        print(f'Step: {len(M) - count + 1}', end = ' ')",
            "        print('Left Shift and Subtract: ', end = ' ')",
            "        A = A[1:] + Q[0]",
            "        comp_M = compliment(M)",
            "        A = add(A, comp_M)",
            "        print(f'A: {A}')",
            "        print(f'A: {A}, Q: {Q[1:]}_', end='')",
            "        if (A[0] == '1'):",
            "            Q = Q[1:] + '0'",
            "            print('  -Unsuccessful')",
            "            A = add(A, M)",
            "            print(f'A: {A}, Q: {Q}  -Restoration')",          
            "        else:",
            "            Q = Q[1:] + '1'",
            "            print('  -Successful')",
            "            print(f'A: {A}, Q: {Q}  -No Restoration')",
            "        count -= 1",         
            "    print()",
            "    print(f'Quotient(Q): {Q}, Remainder(A): {A}')",          
            "if __name__ == \"__main__\":",
            "    tdividend = int(input('Enter dividend: '))",
            "    dividend=decimalToBinary(tdividend)",
            "    tdivisor = int(input('Enter divisor: '))",
            "    divisor='0'+decimalToBinary(tdivisor)",
            "    print(divisor)",
            "    accumulator = '0' * len(dividend)",
            "    restoringDivision(dividend, divisor, accumulator)"
        ],
        "description": "Restoring Division" 
    },
    "NonRestoring Division" : {
        "prefix": "!nonrestoringdivision",
        "body": [
            "def decimalToBinary(n):",
            "    return bin(n).replace(\"0b\", \"\")",           
            "def add(A, M):",
            "    carry = 0",
            "    add_sum = ''",
            "    for i in range(len(A) - 1, -1, -1):",
            "        temp = int(A[i]) + int(M[i]) + carry",
            "        if (temp > 1):",
            "            add_sum += str(temp % 2)",
            "            carry = 1",
            "        else:",
            "            add_sum += str(temp)",
            "            carry = 0",
            "    return add_sum[::-1]",         
            "def compliment(m):",
            "    M = ''",
            "    for i in range(0, len(m)):",
            "        M += str((int(m[i]) + 1) % 2)"   ,
            "    M = add(M, '0' * (len(M) - 1) + '1')",
            "    return M",
            "def nonRestoringDivision(Q, M, A):",
            "    count = len(M)",
            "    comp_M = compliment(M)",
            "    flag = 'successful'",
            "    print('Initial Values: A:', A, ' Q:', Q, ' M:', M)",
            "    while (count):",
            "        print(f'Step: {len(M)-count + 1}', end = ' ')",
            "        print('Left Shift and', end = ' ')",
            "        A = A[1:] + Q[0]",
            "        if (flag == 'successful'):",
            "            A = add(A, comp_M)",
            "            print('Subtraction: ')",
            "        else:",
            "            A = add(A, M)",
            "            print('Addition: ')",
            "        print(f'A: {A}, Q: {Q[1:]}_', end='')",
            "        if (A[0] == '1'):",
            "            Q = Q[1:] + '0'",
            "            print('  -Unsuccessful')",
            "            flag = 'unsuccessful'",
            "            print(f'A: {A}, Q: {Q} -Addition in next Step')",
            "        else:",
            "            Q = Q[1:] + '1'",
            "            print('  Successful')",
            "            flag = 'successful'",
            "            print(f'A: {A}, Q: {Q}, -Subtraction in next step')",
            "        count -= 1",
            "    if (A[0] == '1'):",
            "        A = add(A, M) ",
            "    print()",
            "    print(f'Quotient(Q): {Q}, Remainder(A): {A}')"  ,
            "if __name__ == \"__main__\":",
            "    tdividend = int(input('Enter dividend: '))",
            "    dividend=decimalToBinary(tdividend)",
            "    tdivisor = int(input('Enter divisor: '))",
            "    divisor='0'+decimalToBinary(tdivisor)",
            "    accumulator = '0' * len(dividend)",
            "    nonRestoringDivision(dividend, divisor, accumulator)"
        ],
        "description": "NonRestoring Division" 
    },
    "Booths Algorithm" : {
        "prefix": "!boothsalgorithm",
        "body": [
            "def booths_algorithm():",
            "    multiplicand_dec = getInput(\"Mutiplicand\")",
            "    multiplier_dec = getInput(\"Multiplier\")",
            "    multiplicand_bin = convertDec(multiplicand_dec)",
            "    multiplier_bin = convertDec(multiplier_dec)",
            "    boothsTriumph(multiplicand_bin,multiplier_bin)",
            "    print(\"Decimal Result: \" + str(int(multiplier_dec)*int(multiplicand_dec)))",
            "def boothsTriumph(mcand, plier):",
            "    print(\"Multipcand: \" + mcand + \" Multiplier: \" + plier)",
            "    product = \"00000000\" + plier + \"0\"",
            "    print(\"Product: \" + product)",
            "    print(buildLine(0,mcand,product))",
            "    for i in range(1,9):",
            "        operation = product[len(product)-2:]",
            "        product = perform_operation(product,mcand,operation)",
            "        print(buildLine(i,mcand,product))",
            "    product = shift(product)",
            "    product = product[9:17]",
            "    print(\"Product: \" + product)",
            "    return",
            "def perform_operation(product,mcand,operation):",
            "    if operation == \"00\":",
            "        product = shift(product)",
            "        print(\"No Op\")",
            "        return product",
            "    elif operation == \"01\":",
            "        temp = binAdd(product[0:8],mcand)",
            "        product = temp + product[8:]",
            "        product = shift(product)",
            "        print(\"Add\")",
            "        return product",
            "    elif operation == \"10\":",
            "        product = subtraction(product,mcand)",
            "        product = shift(product)",
            "        print(\"Sub\")",
            "        return product",
            "    elif operation == \"11\":",
            "        product = shift(product)",
            "        print(\"No Op\")",
            "        return product",
            "    else:",
            "        print(\"An error has occured when choosing operation: Exiting program\")",
            "        return 0",
            "def subtraction(product,mcand):",
            "    carry = 0",
            "    prime_product = product[:8]",
            "    final_product = \"\"", 
            "    for i in range(len(prime_product)-1,-1,-1):",
            "        if (mcand[i] == \"0\" and prime_product[i] == \"0\"):",
            "            if (carry == 1):",
            "                final_product = \"1\" + final_product",
            "            else:",
            "                final_product = \"0\" + final_product",
            "        elif (mcand[i] == \"1\" and prime_product[i] == \"0\"):",
            "            if (carry == 1):",
            "                final_product = \"0\" + final_product",
            "            else:",
            "                final_product = \"1\" + final_product",
            "                carry = 1",
            "        elif (mcand[i] == \"0\" and prime_product[i] == \"1\"):",
            "            if (carry == 1):",
            "                final_product = \"0\" + final_product",
            "                carry = 0",
            "            else:",
            "                final_product = \"1\" + final_product",
            "        elif (mcand[i] == \"1\" and prime_product[i] == \"1\"):",
            "            if (carry == 1):",
            "                final_product = \"1\" + final_product",
            "                carry = 1",
            "            else:",
            "                final_product = \"0\" + final_product",
            "        else:",
            "            print(\"An error has occurred when subtracting: Exiting program\")",
            "            return 0",
            "    return final_product + product[8:]",
            "def shift(product):",
            "    product = \"0\"+product[:len(product)-1]",
            "    return product",
            "def binAdd(num, num2):",
            "    product = \"\"",
            "    carry = \"0\"",
            "    for i in range(len(num)-1,-1,-1):",
            "        if carry == \"0\":",
            "            if num[i] == \"0\" and num2[i] == \"0\":",
            "                product = \"0\" + product",
            "            elif num[i] == \"1\" and num2[i] == \"1\": #case 1 and 1",
            "                product = \"0\" + product",
            "                carry = \"1\"",
            "            else:",
            "                product = \"1\" + product",
            "        elif carry == \"1\":",
            "            if num[i] == \"0\" and num2[i] == \"0\":",
            "                product = \"1\" + product",
            "                carry = \"0\"",
            "            elif num[i] == \"1\" and num2[i] == \"1\": #case 1 and 1",
            "                product = \"1\" + product",
            "                carry = \"1\"",
            "            else:",
            "                product = \"0\" + product",
            "                carry = \"1\"",
            "    return product",
            "def buildLine(iteration, mcand, product):",
            "    line = \"Step: \" + str(iteration) + \" | Multiplicand: \" + mcand + \" | Product: \" \\",
            "    + product[0:8] + \" | \" + product[8:16] + \" | \" + product[16]",
            "    return line",
            "def convertDec(dec):",
            "    if int(dec)<0:",
            "        bin = twos_complement(int(dec))",
            "    else:",
            "        bin = \"{0:b}\".format(int(dec))",
            "        for i in range(8-len(bin)):",
            "            bin = \"0\" + bin",
            "    return bin",
            "def getInput(varName):",
            "    boothIn = input('Please enter your ' + varName + \": \")",
            "    while int(boothIn)>127 or int(boothIn)<-128:",
            "        print(\"Absolute value too big, please try again\")",
            "        boothIn = input('Please enter your ' + varName + \": \")",
            "    return boothIn",
            "def twos_complement(dec):",
            "    adjusted = abs(int(dec) + 1)",
            "    binint = \"{0:b}\".format(adjusted)",
            "    flipped = flip(binint)",
            "    for i in range(8-len(flipped)):",
            "        flipped = \"1\" + flipped",
            "    return flipped",
            "def flip(string):",
            "    flipped_string = \"\"",
            "    for bit in string:",
            "        if bit == \"1\":",
            "            flipped_string += \"0\"",
            "        else:",
            "            flipped_string += \"1\"",
            "    return flipped_string",
            "booths_algorithm()"

        ],
        "description": "Booths Algorithm" 
    },

    "MraisedtoN" : {
        "prefix": "!mraisedton",
        "body": [
            "#include<stdio.h> ",
            "#include<conio.h>",
            "#include<string.h>",
            "void main() {",
            "    int m, n, result, i,j;",
            "    clrscr();",
            "    printf(\"Enter no:\");" ,
            "    scanf(\"%d\",&m);",
            "    printf(\"Enter power:\");",
            "    scanf(\"%d\",&n);",
            "    asm{",
            "        mov ax,m"  ,
            "        mov cx,n",
            "        dec cx",
            "    };",
            "    label:",
            "    asm{",
            "        mul m",
            "        dec cx",
            "        jnz label",
            "        mov result,ax",
            "    }",
            "    printf(\"value:%d\\n\",result);",
            "    getch();",
            "}"
        ],
        "description": "MraisedtoN" 
    },

    "Python Pyramid" : {
        "prefix": "!pythonpyramid",
        "body": [
            "n = int(input(\"Enter Number of Lines: \"))",
            "for i in range(1,n+1):",
            "    for j in range(n-i):",
            "        print(\" \",end=\"\")",
            "    for j in range(i):",
            "        print(chr(65+j),end=\"\")",
            "        print(\" \",end=\"\")",
            "    print()" 
        ],
        "description": "Python Pyramid" 
    },
    "Python Triangle" : {
        "prefix": "!pythontriangle",
        "body": [
            "n = int(input(\"Enter Start Number: \"))",
            "for i in range(n+1):",
            "    for j in range(i+1):",
            "        print(n+j-i,end=\" \")",
            "    print()",
            "for i in range(n):",
            "    for j in range(n-i):",
            "        print(i+j+1,end=\" \")",
            "    print()"
        ],
        "description": "Python Triangle" 
    },
    "Python Diamond" : {
        "prefix": "!pythondiamond",
        "body": [
            "n = int(input(\"Enter Number of letters: \"))",
            "for i in range(1,n+1):",
            "    for j in range(n-i):",
            "        print(\" \",end=\"\")",
            "    for j in range(i):",
            "        print(chr(ord('A')+n-i+j),end=\" \")",
            "    print()",
            "for i in range(1,n+1):",
            "    for j in range(i):",
            "        print(\" \",end=\"\")",
            "    for j in range(n-i):",
            "        print(chr(ord('A')+i+j),end=\" \")",
            "    print()"
        ],
        "description": "Python Diamond" 
    },
    "Python File Reverse Lines" : {
        "prefix": "!printlineinreverseorder",
        "body": [
            "f1 = open(\"File1.txt\",\"r\")",
            "lines=f1.readlines()",
            "lines=[i.replace(\"\\n\",\"\") for i in lines]",
            "print(lines)",
            "new_lines=[]",
            "for i in lines:",
            "    temp=''",
            "    for j in range(len(i)):",
            "       temp+=i[len(i)-1-j]",
            "    new_lines.append(temp)",
            "print(new_lines)",
            "f1.close()"
        ],
        "description": "Python File Reverse Lines" 
    },
    "RGM language identifier" : {
        "prefix": "!rgmlanguageidentifier",
        "body": [
            "import re",
            "lines = [\"b6cwwyYt\",\"B3he\",\"a3$\",\"s3iki\",\"e9Bhqia#8\"]",
            "pattern = r\"[a-k][0|3|6|9][a-z|A-Z|0-9|#]*\"",
            "x=[]",
            "for i in lines:",
            "    y=re.findall(pattern,i)",
            "    if len(y)>0 and y[0]== i:",
            "        x.append(y[0])",
            "print(x)"
        ],
        "description": "RGM language identifier" 
    },
    "Valid Mobile Number" : {
        "prefix": "!mobilenumberregex",
        "body": [
            "import re",
            "lines=[\"983765356\",\"1234567890\",\"9780934567\",\"826262626666\"]",
            "pattern =r\"[7|8|9][0-9]{9}\"",
            "x=[]",
            "for i in lines:",
            "    y=re.findall(pattern,i)",
            "    if len(y)>0 and y[0]==i:",
            "        x.append(y[0])",
            "print(x)"
        ],
        "description": "Valid Mobile Number" 
    },
    "Hanoi Problem" : {
        "prefix": "!hanoiproblem",
        "body": [
            "def hanoi(disks,sorc,aux,dest):",
            "    if disks==1:",
            "        print(f\"Move Disk {disks} from {sorc} to {dest}.\")",
            "        return",
            "    hanoi(disks-1,sorc,dest,aux)",
            "    print(f\"Move Disk {disks} from {sorc} to {dest}.\")",
            "    hanoi(disks-1,aux,sorc,dest)",
            "disks = int(input(\"Enter Number of Disks: \"))",
            "hanoi(disks,\"A\",\"B\",\"C\")"
        ],
        "description": "Hanoi Problem" 
    },
    "Exception Handling" : {
        "prefix": "!exceptionhandling",
        "body": [
            "def Valueerror():",
            "    try:",
            "        x = int (input (\"Please enter a number: \"))",
            "    except ValueError:",
            "        print (\"Oops! That was no valid number. Try again...\")",
            "def Import():",
            "    try:",
            "        import request",
            "    except Exception as e:",
            "        print (e)",
            "def Ioerror():",
            "    try:",
            "        file=open(\"hello.txt\",'r')",
            "    except IOError:",
            "        print (\"File does not exist\")",
            "def Arithmetic():",
            "    try:",
            "        n=6",
            "        x=6/0",
            "    except ZeroDivisionError:",
            "        print('You have just made an Arithmetic error')",
            "def Keyboard():",
            "    try:",
            "        x = input()",
            "        print ('Try using KeyboardInterrupt')",
            "    except KeyboardInterrupt:",
            "        print ('KeyboardInterrupt exception is caught')",
            "def name():",
            "    try:",
            "        name = input()",
            "        print(nam)",
            "    except NameError:",
            "        print(\"NameError occurred. Some variable isn't defined.\")",
            "class MyError(Exception):",
            "    def __init__(self, value):",
            "        self.value = value",
            "    def __str__(self):",
            "        return(repr(self.value))",
            "def custom():",
            "    try:",
            "        raise(MyError(3*2))",
            "    except MyError as error:",
            "        print('A New Exception occurred: ', error.value)",
            "    finally:",
            "        print(\"The try...except block is finished\")",
            "Ioerror()",
            "Valueerror()",
            "Arithmetic()",
            "Import()",
            "Keyboard()",
            "name()",
            "custom()"

        ],
        "description": "Exception Handling" 
    },
    "Regex for Website Email" : {
        "prefix": "!regexwebsiteemail",
        "body": [
            "import re",
            "f1 = open(\"File1.txt\",\"r\")",
            "lines = f1.readlines()",
            "f1.close()",
            "lines = [i.replace(\"\\n\",\"\") for i in lines]" ,            
            "name_pattern = r\"[M|m][R|R|S|r|r|s][S|s]{,1}\\..*\"",
            "names=[]",
            "for i in lines:",
            "    y=re.findall(name_pattern,i)",
            "    if len(y)>0 and y[0]==i:",
            "        names.append(y[0])",
            "print(names)"             ,
            "email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z.]{2,}\\b'",
            "emails=[]",
            "for i in lines:",
            "    y=re.findall(email_pattern,i)",
            "    if len(y)>0 and y[0]==i:",
            "        emails.append(y[0])",
            "print(emails)"         ,
            "website_pattern = r\"\\b(http://|https://|www.)[a-zA-Z.]*.[a-zA-Z.]{2,}\"",
            "websites=[]",
            "for i in lines:",
            "    y=re.findall(website_pattern,i)",
            "    if len(y)>0:",
            "        websites.append(i)",
            "print(websites)"         ,
            "number_pattern = r\"\\b[0-9-*]+\"",
            "numberss=[]",
            "for i in lines:",
            "    y=re.findall(number_pattern,i)",
            "    if len(y)>0:",
            "        numberss.append(i)",
            "print(numberss)"
        ],
        "description": "Regex for Website Email" 
    },
    "SQlite3 Python" : {
        "prefix": "!sqlite3python",
        "body": [
            "import sqlite3",
            "myDB= sqlite3.connect(\"test2.db\")",
            "cursor = myDB.cursor()",
            "print()",
            "x=1"          ,   
            "while(x):"         ,  
            "    y=int(input(\"Enter 1 to create table\\n2 to insert value\\n3 to delete value\\n4 to display\\n5 to update\\n0 to exit\\n \"))",
            "    x=y",
            "    if(x==1):",
            "        cursor.execute(\"\"\"CREATE TABLE marks (id int(11),name varchar(50) NOT NULL, total_marks int(3), PRIMARY KEY (id) )\"\"\")",
            "    if(x==2):",
            "        cursor.execute(\"\"\" INSERT INTO marks(id,name,total_marks) VALUES (1,\"roy\",82)\"\"\")",
            "        cursor.execute(\"\"\" INSERT INTO marks(id,name,total_marks) VALUES (2,\"loy\",89)\"\"\")",
            "        myDB.commit()",
            "    if(x==3):",
            "        cursor.execute(\"\"\" DELETE from marks WHERE id=2 \"\"\")"        ,
            "        myDB.commit()",
            "    if(x==4):",
            "        cursor.execute(\"\"\" SELECT * FROM marks \"\"\")",
            "        for x in cursor:",
            "            print(x)",
            "    if(x==5):",
            "        cursor.execute(\"\"\" UPDATE marks SET total_marks = 50 WHERE id=1 \"\"\")"    ,
            "        myDB.commit()",
            "    if(x==0):",
            "        break",
            "myDB.commit()"
        ],
        "description": "SQlite3 Python"
    },

    "Pandas Python" :{
        "prefix": "!pandas python",
        "body": [
            "import pandas as pd",
            "import seaborn as sns",
            "import matplotlib.pyplot as plt"   ,          
            "df = pd.read_csv(\"Iris.csv\")"   ,          
            "df.head()"     ,       
            "df.info()"     ,       
            "#df.dropna(axis=0,how='any')" ,          
            "df['PetalLengthCm']=df['PetalLengthCm'].fillna(df['PetalLengthCm'].mean())"    ,      
            "df.info()"       ,
            "df.dropna(axis=0,how='any')"       ,
            "df.info()"        ,
            "df.describe()"        ,
            "sns.boxplot(df['SepalLengthCm']) "     ,
            "df['Species'].unique()",
            "plt.figure(figsize=(10,10))"    ,
            "means=[]",
            "for i in df['Species'].unique():",
            "  means.append(df[df[\"Species\"]==i][\"SepalLengthCm\"].mean())",
            "plt.bar(x=df['Species'].unique(), height=means)",
            "plt.show() ",
            "plt.pie(x=means,labels=df['Species'].unique())",
            "plt.show()" ,
            "plt.scatter(x=df['PetalLengthCm'],y=df['Species'])",
            "plt.show()",
            "plt.hist(x=df['PetalLengthCm'],bins=10)",
            "plt.show()"
        ],
        "description": "Pandas Python"
    },
    "Tkinter Input Output" :{
        "prefix": "!tkinterinputoutput",
        "body": [
            "from tkinter import *",
            "window= Tk()",
            "window.geometry(\"300x300\") " ,
            "def evaluate():",
            "    x1=first_entry.get()",
            "    x2=second_entry.get()",
            "    op = Operator_entry.get()",
            "    eq = x1+op+x2",
            "    result_entry.config(text=f\"{eval(eq)}\") "   ,    
            "first_value = Label(text=\"Enter Number1: \")",
            "first_value.grid(row=0,column=0)",
            "first_entry = Entry(width=30)",
            "first_entry.grid(row=0,column=1)"  ,
            "second_value = Label(text=\"Enter Number2: \")",
            "second_value.grid(row=1,column=0)",
            "second_entry = Entry(width=30)",
            "second_entry.grid(row=1,column=1)"    ,
            "Operator_value = Label(text=\"Operator: \")",
            "Operator_value.grid(row=2,column=0)",
            "Operator_entry = Entry(width=30)",
            "Operator_entry.grid(row=2,column=1)"  ,  
            "result_value = Label(text=\"Result: \")",
            "result_value.grid(row=3,column=0)",
            "result_entry = Label(text=\"\")",
            "result_entry.grid(row=3,column=1)"  ,
            "btn = Button(text=\"Enter\",command=evaluate)",
            "btn.grid(row=4,column=0,columnspan=2)" ,
            "window.mainloop()"
        ],
        "description": "Tkinter Input Output"
    },
    "Page Rank Algorithm" :{
        "prefix": "!pagerankalgorithm",
        "body": [
            "import numpy as np",
            "def page_rank_algorithm(graph,damping_factor):",
            "    outgoing = dict()",
            "    incoming_nodes = dict()",
            "    coefficients = dict()",
            "    for i in range(len(graph)):",
            "        outgoing[i]=0",
            "    for i,node in enumerate(graph):",
            "        for edge in node:",
            "            if edge:",
            "                outgoing[i] += 1",
            "    for i in range(len(graph)):",
            "        temp=[]",
            "        for node in graph:",
            "            if node[i]:",
            "                temp.append(node)",
            "        incoming_nodes[i] = temp",
            "    for i,node in enumerate(graph):",
            "        temp = []",
            "        for j,other_node in enumerate(graph):",
            "            if other_node in incoming_nodes[i]:",
            "                temp.append(damping_factor*(1.0/outgoing[j]))",
            "            elif i == j:",
            "                temp.append(-1)",
            "            else:",
            "                temp.append(0)",
            "        coefficients[i] = temp",
            "    coefficients_list = []",
            "    for key,value in coefficients.items():",
            "        coefficients_list.append(value)",
            "    constant_matrix = []",
            "    for i in range(len(graph)):",
            "        constant_matrix.append(damping_factor-1)",
            "    pageranks = np.linalg.solve(np.array(coefficients_list),np.array(constant_matrix))",
            "    print()",
            "    for i,rank in enumerate(pageranks):",
            "        print('Page Rank of {} is {:.4f}'.format(chr(65+i), rank))",
            "def main():",
            "    n = int(input('Enter the number of nodes : '))",
            "    d= float(input('Enter the damping factor : '))",
            "    graph = []",
            "    print('Enter Adjacency Matrix with terms separated by a space : ')",
            "    for i in range(n):",
            "        temp_list = input().split(' ')",
            "        graph.append(list(map(int,temp_list)))",
            "    page_rank_algorithm(graph,d)",
            "main()"            
        ],
        "description": "Page Rank Algorithm"
    },
    "Hits Algorithm" :{
        "prefix": "!hitsalgorithm",
        "body": [
            "from math import sqrt",
            "def hits_algorithm(num_nodes, graph, iterations):",
            "    authority_scores = dict()",
            "    hub_scores = dict()",
            "    for i in range(len(graph)):",
            "        authority_scores[i] = 1",
            "        hub_scores[i] = 1",
            "    incoming_nodes = dict()",
            "    for i in range(len(graph)):",
            "        temp=[]",
            "        for node in graph:",
            "            if node[i]:",
            "                temp.append(node)",
            "        incoming_nodes[i] = temp",
            "    outgoing_nodes = dict()",
            "    for i,node in enumerate(graph):",
            "        temp = []",
            "        for j,edge in enumerate(node):",
            "            if edge:",
            "                temp.append(graph[j])",
            "        outgoing_nodes[i] = temp",
            "    print()",
            "    for k in range(iterations):",
            "        print('Iteration : ',k+1)",
            "        print('Authority Score')",
            "        normalization_value = 0",
            "        for i,node in enumerate(graph):",
            "            authority_scores[i]=0",
            "            for j,other_node in enumerate(graph):",
            "                if other_node in incoming_nodes[i]:",
            "                    authority_scores[i] += hub_scores[j]",
            "            normalization_value += (authority_scores[i]**2)",
            "        normalization_value = sqrt(normalization_value)",
            "        for i in range(num_nodes):",
            "            authority_scores[i] /= normalization_value",
            "            print('{} :{:.2f}'.format(chr(65+i),authority_scores[i]),end=' | ')",
            "        print()",
            "        print('Hub Score')",
            "        normalization_value = 0",
            "        for i,node in enumerate(graph):",
            "            hub_scores[i]=0",
            "            for j,other_node in enumerate(graph):",
            "                if other_node in outgoing_nodes[i]:",
            "                    hub_scores[i] += authority_scores[j]",
            "            normalization_value += (hub_scores[i]**2)",
            "        normalization_value = sqrt(normalization_value)",
            "        for i in range(num_nodes):",
            "            hub_scores[i] /= normalization_value",
            "            print('{} :{:.2f}'.format(chr(65+i),hub_scores[i]),end=' | ')",
            "        print(\"\\n\\n\")",
            "def main():",
            "    n = int(input('Enter the no of nodes : '))",
            "    graph = []",
            "    print('Enter Adjacency Matrix : ')",
            "    for i in range(n):",
            "        temp = input()",
            "        temp_list = temp.split(' ')",
            "        graph.append(list(map(int,temp_list)))",
            "    k = int(input('Enter No of Iterations to be performed : '))",
            "    hits_algorithm(n, graph, k)",
            "main()"
            
        ],
        "description": "Page Rank Algorithm"
    }



}