{
    "Genetic Algorithm Starter Template":{
        "prefix": "!geneticAlgo",
        "body" : [
            "import numpy",
            "genes = 2",
            "chromosomes = 10",
            "mattingPoolSize = 6",
            "offspringSize = chromosomes - mattingPoolSize",
            "lb = -5",
            "ub = 5",
            "populationSize = (chromosomes, genes)",
            "generations = 3",
            "population = numpy.random.uniform(lb, ub, populationSize)",
            "for generation in range(generations):",
            "    print((\"Generation:\", generation+1))",
            "    fitness = numpy.sum(population*population, axis=1)",
            "    print(\"\\npopulation\")",
            "    print(population)",
            "    print(\"\\nfitness calcuation\")",
            "    print(fitness)",
            "    parents = numpy.empty((mattingPoolSize, population.shape[1]))",
            "    for p in range(mattingPoolSize):",
            "       fittestIndex = numpy.where(fitness == numpy.max(fitness))",
            "       fittestIndex = fittestIndex[0][0]",
            "       parents[p, :] = population[fittestIndex, :]",
            "       fitness[fittestIndex] = -1",
            "       print(\"\\nParents:\")",
            "       print(parents)",
            "       offspring = numpy.empty((offspringSize, population.shape[1]))",
            "    for k in range(offspringSize):",
            "       crossoverPoint = numpy.random.randint(0,genes)",
            "       parent1Index = k%parents.shape[0]",
            "       parent2Index = (k+1)%parents.shape[0]",
            "       offspring[k, 0: crossoverPoint] = parents[parent1Index, 0: crossoverPoint]",
            "       offspring[k, crossoverPoint:] = parents[parent2Index, crossoverPoint:]",
            "    print(\"\\nOffspring after crossover:\")",
            "    print(offspring)",
            "    for index in range(offspring.shape[0]):",
            "       randomIndex = numpy.random.randint(1,genes)",
            "       randomValue = numpy.random.uniform(lb, ub, 1)",
            "       offspring [index, randomIndex] = offspring [index, randomIndex] + randomValue",
            "    print(\"\\n Offspring after Mutation\")",
            "    print(offspring)",
            "    population[0:parents.shape[0], :] = parents",
            "    population[parents.shape[0]:, :] = offspring",
            "    print(\"\\nNew Population for next generation:\")",
            "    print(population)",
            "fitness = numpy.sum(population*population, axis=1)",
            "fittestIndex = numpy.where(fitness == numpy.max(fitness))",
            "fittestIndex = fittestIndex[0][0]",
            "fittestInd = population[fittestIndex, :]",
            "bestFitness = fitness[fittestIndex]",
            "print(\"\\nBest Individual:\")",
            "print(fittestInd)",
            "print(\"\\nBest Individual's Fitness:\")",
            "print(bestFitness)"            
        ],
        "description": "Genetic Algorithm Starter Template"
    },
    "Descending order Assembly Language":{
        "prefix": "!descendingOrder",
        "body": [
            "MOV SI,1100H",
            "MOV CL,[SI]",
            "DEC CL",
            "REPEAT:",
            "MOV SI,1100H",
            "MOV CH,[SI]",
            "DEC CH",
            "INC SI",
            "RECOMP:",
            "MOV AL,[SI]",
            "INC SI",
            "CMP AL,[SI]",
            "JNC AHEAD"  ,              
            "XCHG AL,[SI]",
            "XCHG AL,[SI-1]",
            "AHEAD:",
            "DEC CH",
            "JNZ RECOMP",
            "DEC CL",
            "JNZ REPEAT",
            "HLT"  
        ],
        "description": "Descending order Assembly Language"
    },
    "Ascending order Assembly Language":{
        "prefix": "!ascendingOrder",
        "body": [
            "MOV SI,1100H",
            "MOV CL,[SI]",
            "DEC CL",
            "REPEAT:",
            "MOV SI,1100H",
            "MOV CH,[SI]",
            "DEC CH",
            "INC SI",
            "RECOMP:",
            "MOV AL,[SI]",
            "INC SI",
            "CMP AL,[SI]",
            "JC AHEAD",
            "XCHG AL,[SI]",
            "XCHG AL,[SI-1]",
            "AHEAD:",
            "DEC CH",
            "JNZ RECOMP",
            "DEC CL",
            "JNZ REPEAT",
            "HLT"
        ],
        "description": "Ascending order Assembly Language"
    },
    "Shortest Number Assembly Language":{
        "prefix": "!shortestNumber",
        "body": [
            "MOV SI,1100H",
            "MOV DI,1200H",
            "MOV CL,[SI]",
            "INC SI",
            "MOV AL,[SI]",
            "DEC CL",
            "AGAIN:",
            "INC SI",
            "MOV BL,[SI]",
            "CMP AL,BL",
            "JC AHEAD",         
            "MOV AL,BL",
            "AHEAD:",
            "DEC CL",
            "JNZ AGAIN",
            "MOV [DI],AL",
            "HLT"   
        ],
        "description": "Shortest Number Assembly Language"
    },
    "Largest Number Assembly Language":{
        "prefix": "!largestNumber",
        "body": [
            "MOV SI,1100H",
            "MOV DI,1200H",
            "MOV CL,[SI]",
            "INC SI",
            "MOV AL,[SI]",
            "DEC CL",
            "AGAIN:",
            "INC SI",
            "MOV BL,[SI]",
            "CMP AL,BL",
            "JNC AHEAD",
            "MOV AL,BL",
            "AHEAD:",
            "DEC CL",
            "JNZ AGAIN",
            "MOV [DI],AL",
            "HLT"
        ],
        "description": "Largest Number Assembly Language"
    },
    "Factorial without macros":{
        "prefix": "!factorialwithoutmacros",
        "body": [
            "DATA SEGMENT",
            "A DB 5",
            "fact DB ?",
            "DATA ENDS",
            "CODE SEGMENT",
            "         ASSUME DS:DATA,CS:CODE",
            "START:",
            "      MOV AX,DATA",
            "      MOV DS,AX",
            "      MOV AH,00",
            "      MOV AL,A",
            " L1:  DEC A",
            "      MUL A",
            "      MOV CL,A",
            "      CMP CL,01",
            "      JNZ L1",
            "      MOV fact, AL",
            "CODE ENDS",
            "END START"
            
        ],
        "description": "Factorial without macros"
    },
    "Factorial using macros":{
        "prefix": "!factorialwithmacros",
        "body": [
            "DATA SEGMENT",
            "A DB 5",
            "fact DB ?",
            "DATA ENDS",
            "CODE SEGMENT",
            "         ASSUME DS:DATA,CS:CODE",
            "START:",
            "      MOV AX,DATA",
            "      MOV DS,AX",
            "      MOV AH,00",
            "      MOV AL,A",
            " L1:  DEC A",
            "      MUL A",
            "      MOV CL,A",
            "      CMP CL,01",
            "      JNZ L1",
            "      MOV fact, AL",
            "CODE ENDS",
            "END START"
            
        ],
        "description": "Factorial using macros"
    },

}